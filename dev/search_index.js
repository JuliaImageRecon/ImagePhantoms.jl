var documenterSearchIndex = {"docs":
[{"location":"generated/examples/32-ellipsoid/#32-ellipsoid","page":"Ellipsoid","title":"Ellipsoid","text":"This page illustrates the Ellipsoid shape in the Julia package ImagePhantoms.\n\nThis page comes from a single Julia file: 32-ellipsoid.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 32-ellipsoid.ipynb, or open it in binder here: 32-ellipsoid.ipynb.","category":"section"},{"location":"generated/examples/32-ellipsoid/#Setup","page":"Ellipsoid","title":"Setup","text":"Packages needed here.\n\nusing ImagePhantoms: Object, phantom, radon, spectrum\nusing ImagePhantoms: Ellipsoid, ellipsoid\nimport ImagePhantoms as IP\nusing ImageGeoms: ImageGeom, axesf\nusing MIRTjim: jim, prompt, mid3\nusing FFTW: fft, fftshift, ifftshift\nusing LazyGrids: ndgrid\nusing Unitful: mm, unit, °\nusing Plots: plot, plot!, scatter!, default\nusing Plots # gif @animate\ndefault(markerstrokecolor=:auto)\n\nThe following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/32-ellipsoid/#Overview","page":"Ellipsoid","title":"Overview","text":"A basic shape used in constructing 3D digital image phantoms is the ellipsoid, specified by its center, radii, angle(s) and value. All of the methods in ImagePhantoms support physical units, so we use such units throughout this example. (Using units is recommended but not required.)\n\nHere are 3 ways to define an Object{Ellipsoid}, using physical units.\n\ncenter = (20mm, 10mm, 5mm)\nradii = (25mm, 35mm, 15mm)\nϕ0s = :(π/6) # symbol version for nice plot titles\nϕ0 = eval(ϕ0s)\nangles = (ϕ0, 0, 0)\nObject(Ellipsoid(), center, radii, angles, 1.0f0) # top-level constructor\nellipsoid( 20mm, 10mm, 5mm, 25mm, 35mm, 15mm, π/6, 0, 0, 1.0f0 ) # 9 arguments\nob = ellipsoid(center, radii, angles, 1.0f0) # tuples (recommended use)","category":"section"},{"location":"generated/examples/32-ellipsoid/#Phantom-image-using-phantom","page":"Ellipsoid","title":"Phantom image using phantom","text":"Make a 3D digital image of it using phantom and display it. We use ImageGeoms to simplify the indexing.\n\ndeltas = (1.0mm, 1.1mm, 0.9mm)\ndims = (2^8, 2^8+2, 49) # odd\nig = ImageGeom( ; dims, deltas, offsets=:dsp)\noversample = 2\nimg = phantom(axes(ig)..., [ob], oversample)\np1 = jim(axes(ig), img;\n   title=\"Ellipsoid, rotation ϕ=$ϕ0s\", xlabel=\"x\", ylabel=\"y\")\n\nThe image integral should match the object volume:\n\nvolume = IP.volume(ob)\n(sum(img)*prod(ig.deltas), volume)\n\nShow middle slices\n\njim(mid3(img), \"Middle 3 planes\")","category":"section"},{"location":"generated/examples/32-ellipsoid/#Spectrum-using-spectrum","page":"Ellipsoid","title":"Spectrum using spectrum","text":"There are two ways to examine the spectrum of this 3D image:\n\nusing the analytical Fourier transform of the object via spectrum\napplying the DFT via FFT to the digital image.\n\nBecause the shape has units mm, the spectra axes have units cycles/mm. Appropriate frequency axes for DFT are provided by axesf(ig).\n\nvscale = 1 / volume # normalize spectra by volume\nspectrum_exact = spectrum(axesf(ig)..., [ob]) * vscale\nsp = z -> max(log10(abs(z)/oneunit(abs(z))), -6) # log-scale for display\nclim = (-6, 0) # colorbar limit for display\n(xlabel, ylabel) = (\"ν₁\", \"ν₂\")\np2 = jim(axesf(ig), sp.(spectrum_exact), \"log10|Spectrum|\"; clim, xlabel, ylabel)\n\nSadly fft cannot handle units currently, so this function is a work-around:\n\nfunction myfft(x)\n    u = unit(eltype(x))\n    return fftshift(fft(ifftshift(x) / u)) * u\nend\n\nspectrum_fft = myfft(img) * (prod(ig.deltas) * vscale)\np3 = jim(axesf(ig), sp.(spectrum_fft), \"log10|DFT|\"; clim, xlabel, ylabel)\n\nCompare the DFT and analytical spectra to validate the code\n\nerrf = maximum(abs, spectrum_exact - spectrum_fft) / maximum(abs, spectrum_exact)\n@assert errf < 3e-3\np4 = jim(axesf(ig), 1e3*abs.(spectrum_fft - spectrum_exact);\n   title=\"|Difference| × 10³\", xlabel, ylabel)\njim(p1, p4, p2, p3)","category":"section"},{"location":"generated/examples/32-ellipsoid/#Parallel-beam-projections-using-radon","page":"Ellipsoid","title":"Parallel-beam projections using radon","text":"Compute 2D projection views of the object using radon. Validate it using the projection-slice theorem aka Fourier-slice theorem.\n\npg = ImageGeom((2^8,2^7), (0.6mm,1.0mm), (0.5,0.5)) # projection sampling\nϕs, θs = (:(π/2), ϕ0s), (:(π/7), :(0))\nϕ, θ = [eval.(ϕs)...], [eval.(θs)...]\nproj2 = [radon(axes(pg)..., ϕ[i], θ[i], [ob]) for i in 1:2] # 2 projections\nsmax = ob.value * maximum(ob.width) * 2\np5 = jim(axes(pg)..., proj2; xlabel=\"u\", ylabel=\"v\", title =\n    \"Projections at (ϕ,θ) = ($(ϕs[1]), $(θs[1])) and ($(ϕs[2]), $(θs[2]))\")\n\nBecause the ellipsoid has major axis of length 70mm and one of the two views above was along that axis, the maximum projection value is about 70mm.\n\nmaxes = round.((smax, maximum.(proj2)...) ./ 1mm; digits=2)\n\nThe integral of each projection should match the object volume:\n\nvols  = round.(((p -> sum(p)*prod(pg.deltas)).(proj2)..., volume) ./ 1mm^3; digits=2)\n\nLook at a set of projections as the views orbit around the object.\n\nϕd = 0:6:360\nϕs = deg2rad.(ϕd)\nθs = :(π/7)\nθ = eval(θs)\nprojs = radon(axes(pg)..., ϕs, [θ], [ob]) # many projection views\n\nif isinteractive()\n    jim(axes(pg)..., projs; title=\"projection views $(ϕd)\")\nelse\n    anim = @animate for ip in 1:length(ϕd)\n        jim(axes(pg), projs[:,:,ip,1]; xlabel=\"u\", ylabel=\"v\", prompt=false,\n            title=\"ϕ=$(ϕd[ip])° θ=$θs\", clim = (0,1) .* smax)\n    end\n    gif(anim, \"ellipsoid.gif\", fps = 6)\nend\n\nThe above sampling generated a parallel-beam projection, but one could make a cone-beam projection by sampling (u, v, ϕ, θ) appropriately. See Sinograms.jl.","category":"section"},{"location":"generated/examples/32-ellipsoid/#Fourier-slice-theorem-illustration","page":"Ellipsoid","title":"Fourier-slice theorem illustration","text":"Pick one particular view and compare its FFT to a slice through the 3D object spectrum.\n\nϕs, θs = :(π/3), :(π/7)\nϕ, θ = eval.((ϕs, θs))\nproj = radon(axes(pg)..., ϕ, θ, [ob])\np6 = jim(axes(pg), proj; xlabel=\"u\", ylabel=\"v\", prompt=false,\n    title = \"Projection at (ϕ,θ) = ($ϕs, $θs)\")\n\ne1 = (cos(ϕ), sin(ϕ), 0)\ne3 = (sin(ϕ)*sin(θ), -cos(ϕ)*sin(θ), cos(θ))\nfu, fv = ndgrid(axesf(pg)...)\nff = vec(fu) * [e1...]' + vec(fv) * [e3...]' # fx,fy,fz for Fourier-slice theorem\nspectrum_slice = spectrum(ob).(ff[:,1], ff[:,2], ff[:,3]) * vscale\nspectrum_slice = reshape(spectrum_slice, pg.dims)\nclim = (-6, 0) # colorbar limit for display\n(xlabel, ylabel) = (\"νᵤ\", \"νᵥ\")\np7 = jim(axesf(pg), sp.(spectrum_slice); prompt=false,\n    title = \"log10|Spectrum Slice|\", clim, xlabel, ylabel)\nproj_fft = myfft(proj) * prod(pg.deltas) * vscale\np8 = jim(axesf(pg), sp.(proj_fft); prompt=false,\n     title = \"log10|FFT Spectrum|\", clim, xlabel, ylabel)\n\nerrs = maximum(abs, spectrum_slice - proj_fft) / maximum(abs, spectrum_slice)\n@assert errs < 1e-3\np9 = jim(axesf(pg), 1e3*abs.(proj_fft - spectrum_slice);\n    title=\"|Difference| × 10³\", xlabel, ylabel, prompt=false)\njim(p6, p7, p8, p9)\n\nThe good agreement between the 2D slice through the 3D analytical spectrum and the FFT of the 2D projection view validates that phantom, radon, and spectrum are all self consistent for this shape.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/04-gauss/#04-gauss","page":"2D Gaussian","title":"2D Gaussian","text":"This page illustrates the Gauss2 shape in the Julia package ImagePhantoms.\n\nThis page comes from a single Julia file: 04-gauss.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 04-gauss.ipynb, or open it in binder here: 04-gauss.ipynb.","category":"section"},{"location":"generated/examples/04-gauss/#Setup","page":"2D Gaussian","title":"Setup","text":"Packages needed here.\n\nusing ImagePhantoms: gauss2\nusing ImagePhantoms: phantom, radon, spectrum\nimport ImagePhantoms as IP\nusing ImageGeoms: ImageGeom, axesf\nusing MIRTjim: jim, prompt\nusing FFTW: fft, fftshift, ifftshift\nusing Unitful: mm, unit, °\nusing Plots: plot, plot!, scatter!, default\ndefault(markerstrokecolor=:auto)\n\nThe following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/04-gauss/#Overview","page":"2D Gaussian","title":"Overview","text":"A useful shape for constructing 2D digital image phantoms is the 2D Gaussian, specified by its center, fwhm, angles and value. All of the methods in ImagePhantoms support physical units, so we use such units throughout this example. (Using units is recommended but not required.)\n\nDefine a 2D Gaussian object, using physical units.\n\nwidth = (50mm, 20mm) # full-width at half-maximum (FHWM)\nob = gauss2((20mm, 30mm), width, π/6, 1.0f0)","category":"section"},{"location":"generated/examples/04-gauss/#Phantom-image-using-phantom","page":"2D Gaussian","title":"Phantom image using phantom","text":"Make a digital image of it using phantom and display it.\n\ndx, dy = 1.2mm, 1.0mm\nM, N = (2^8, 2^8+2)\nx = (-M÷2:M÷2-1) * dx\ny = (-N÷2:N÷2-1) * dy\noversample = 2\nimg = phantom(x, y, [ob], oversample)\njim(x, y, img, \"2D Gaussian image\")\n\nHereafter we use ImageGeoms to simplify the indexing.\n\nM, N = (2^8, 2^8+17) # odd\nig = ImageGeom(dims=(M,N), deltas=(dx,dy), offsets=:dsp)\n@assert axes(ig)[1] ≈ x\noversample = 2\nimg = phantom(axes(ig)..., [ob], oversample)\np1 = jim(axes(ig), img, \"2D Gaussian phantom\", xlabel=\"x\", ylabel=\"y\")\n\nThe image integral should approximate the object area\n\narea = IP.area(ob)\n(sum(img) * prod(ig.deltas), area)","category":"section"},{"location":"generated/examples/04-gauss/#Spectrum-using-spectrum","page":"2D Gaussian","title":"Spectrum using spectrum","text":"There are two ways to examine the spectrum of this image:\n\nusing the analytical Fourier transform of the object via spectrum\napplying the DFT via FFT to the digital image.\n\nBecause the shape has units mm, the spectra axes have units cycles/mm.\n\nvscale = 1 / area # normalize spectra by area\nspectrum_exact = spectrum(axesf(ig)..., [ob]) * vscale\nsp = z -> max(log10(abs(z)/oneunit(abs(z))), -6) # log-scale for display\nclim = (-6, 0) # colorbar limit for display\n(xlabel, ylabel) = (\"ν₁\", \"ν₂\")\np2 = jim(axesf(ig), sp.(spectrum_exact), \"log10|Spectrum|\"; clim, xlabel, ylabel)\n\nSadly fft cannot handle units currently, so this function is a work-around:\n\nfunction myfft(x)\n    u = unit(eltype(x))\n    return fftshift(fft(ifftshift(x) / u)) * u\nend\n\nspectrum_fft = myfft(img) * (prod(ig.deltas) * vscale)\np3 = jim(axesf(ig), sp.(spectrum_fft), \"log10|DFT|\"; clim, xlabel, ylabel)\n\nCompare the DFT and analytical spectra to validate the code\n\nerrf = maximum(abs, spectrum_exact - spectrum_fft) / maximum(abs, spectrum_exact)\n@assert errf < 4e-4\np4 = jim(axesf(ig), 1e3*abs.(spectrum_fft - spectrum_exact),\n    \"|Difference| × 10³\"; xlabel, ylabel)\n    #src \"Difference|| × 10³\"; xlabel, ylabel)\n    #src \"Difference∠\"; xlabel, ylabel)\njim(p1, p4, p2, p3)","category":"section"},{"location":"generated/examples/04-gauss/#Radon-transform-using-radon","page":"2D Gaussian","title":"Radon transform using radon","text":"Examine the Radon transform of the object using radon, and validate it using the projection-slice theorem aka Fourier-slice theorem.\n\ndr = 0.2mm # radial sample spacing\nnr = 2^10 # radial sinogram bins\nr = (-nr÷2:nr÷2-1) * dr # radial samples\nfr = (-nr÷2:nr÷2-1) / nr / dr # corresponding spectral axis\nϕ = deg2rad.(0:180)\nsino = radon(ob).(r, ϕ') # sample Radon transform of a single shape object\nsmax = ob.value * IP.fwhm2spread(50mm)\np5 = jim(r, rad2deg.(ϕ), sino; title=\"sinogram\",\n    xlabel=\"r\", ylabel=\"ϕ\", clim = (0,1) .* smax)\n\nThe maximum sinogram value is about fwhm2spread(50mm) = 50mm * sqrt(π / log(16)) ≈ 53mm which makes sense for a 2D Gaussian whose longest axis has FWHM = 50mm.\n\nThe above sampling generated a parallel-beam sinogram, but one could make a fan-beam sinogram by sampling (r, ϕ) appropriately.","category":"section"},{"location":"generated/examples/04-gauss/#Fourier-slice-theorem-illustration","page":"2D Gaussian","title":"Fourier-slice theorem illustration","text":"Pick one particular view angle (55°) and look at its slice and spectra.\n\nia = argmin(abs.(ϕ .- 55°))\nslice = sino[:,ia]\nslice_fft = myfft(slice) * dr\nϕd = round(rad2deg(ϕ[ia]), digits=1)\n\nkx, ky = (fr * cos(ϕ[ia]), fr * sin(ϕ[ia])) # Fourier-slice theorem\nslice_ft = spectrum(ob).(kx, ky)\nerrs = maximum(abs, slice_ft - slice_fft) / maximum(abs, slice_ft)\n@assert errs < 4e-4\n\np3 = plot(r, slice, title=\"profile at ϕ = $ϕd\", label=\"\")\np4 = plot(title=\"1D spectra\")\nscatter!(fr, abs.(slice_fft), label=\"abs fft\", color=:blue)\nscatter!(fr, real(slice_fft), label=\"real fft\", color=:green)\nscatter!(fr, imag(slice_fft), label=\"imag fft\", color=:red,\n    xlims=(-1,1) .* (0.08/mm))\n\nplot!(fr, abs.(slice_ft), label=\"abs\", color=:blue)\nplot!(fr, real(slice_ft), label=\"real\", color=:green)\nplot!(fr, imag(slice_ft), label=\"imag\", color=:red)\nplot(p1, p5, p3, p4)\n\nThe good agreement between the analytical spectra (solid lines) and the DFT samples (disks) validates that phantom, radon, and spectrum are all self consistent for this shape.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/10-mri-sense/#10-mri-sense","page":"MRI SENSE","title":"MRI SENSE","text":"This page illustrates the mri_smap_fit and mri_spectra methods in the Julia package ImagePhantoms for performing MRI simulations with realistic sensitivity encoding (SENSE).\n\nThis page comes from a single Julia file: 10-mri-sense.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 10-mri-sense.ipynb, or open it in binder here: 10-mri-sense.ipynb.","category":"section"},{"location":"generated/examples/10-mri-sense/#Setup","page":"MRI SENSE","title":"Setup","text":"Packages needed here.\n\nusing ImagePhantoms: ellipse_parameters, SheppLoganBrainWeb, ellipse\nusing ImagePhantoms: phantom, mri_smap_fit, mri_spectra\nusing FFTW: fft, fftshift\nusing ImageGeoms: embed\nusing LazyGrids: ndgrid\nusing MIRTjim: jim, prompt\nusing Random: seed!\nusing Unitful: mm\n\nThe following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/10-mri-sense/#Overview","page":"MRI SENSE","title":"Overview","text":"Modern MRI scanners use multiple receive coils each of which has its own \"sensitivity map\" (or \"coil profile\"). Realistic MRI simulations should account for the effects of those sensitivity maps analytically, rather than committing the \"inverse crime\" of using rasterized phantoms and maps.\n\nSee the 2012 paper Guerquin-Kern et al. that combines analytical k-space values of the phantom with an analytical model for the sensitivity maps. This package follows the recommended approach from that paper. We used the mri_smap_fit function to fit each sensitivity map with a modest number of complex exponential signals. Then, instead of using the spectrum function we use the spectra function to generate simulated k-space data from analytical phantoms (like ellipses).\n\nBecause FFTW.fft cannot handle units, this function is a work-around.\n\nfunction myfft(x::AbstractArray{T}) where {T <: Number}\n    u = oneunit(T)\n    return fftshift(fft(fftshift(x) / u)) * u\nend","category":"section"},{"location":"generated/examples/10-mri-sense/#Phantom","page":"MRI SENSE","title":"Phantom","text":"Image geometry:\n\nfovs = (256mm, 250mm)\nnx, ny = (128, 100) .* 2\ndx, dy = fovs ./ (nx,ny)\nx = (-(nx÷2):(nx÷2-1)) * dx\ny = (-(ny÷2):(ny÷2-1)) * dy\n\nDefine Shepp-Logan phantom object, with random complex phases to make it a bit more realistic.\n\nparams = ellipse_parameters(SheppLoganBrainWeb() ; disjoint=true, fovs)\nseed!(0)\nphases = [1; rand(ComplexF32,9)] # random phases\nparams = [(p[1:5]..., phases[i]) for (i, p) in enumerate(params)]\noa = ellipse(params)\noversample = 3\nimage0 = phantom(x, y, oa, oversample)\ncfun = z -> cat(dims = ndims(z)+1, real(z), imag(z))\njim(x, y, cfun(image0), \"Digital phantom\\n (real | imag)\")\n\nIn practice, sensitivity maps are usually estimated only over portion of the image array, so we define a simple mask here to exercise this issue.\n\nmask = trues(nx,ny)\nmask[:,[1:2;end-2:end]] .= false\nmask[[1:8;end-8:end],:] .= false\n@assert mask .* image0 == image0\njim(x, y, mask, \"mask\")","category":"section"},{"location":"generated/examples/10-mri-sense/#Sensitivity-maps","page":"MRI SENSE","title":"Sensitivity maps","text":"Here we use highly idealized sensitivity maps, roughly corresponding to the Biot-Savart law for an infinite thin wire, as a crude approximation of a birdcage coil. One wire is outside the upper right corner, the other is outside the left border.\n\nresponse at (x,y) to wire at (wx,wy)\n\nfunction biot_savart_wire(x, y, wx, wy)\n    phase = cis(atan(y-wy, x-wx))\n    return oneunit(x) / sqrt(sum(abs2, (x-wx, y-wy))) * phase # 1/r falloff\nend\n\nncoil = 2\nwire1 = (a,b) -> biot_savart_wire(a, b, maximum(x) + 8dx, maximum(y) + 8dy)\nwire2 = (a,b) -> biot_savart_wire(a, b, minimum(x) - 20dx, zero(dy))\nsmap = [wire1.(x, y'), wire2.(x, y')]\nsmap[1] *= cis(3π/4) # match coil phases at image center, ala \"quadrature phase\"\nsmap = cat(dims=3, smap...)\nsmap /= maximum(abs, smap)\nmag = abs.(smap)\nphase = angle.(smap)\n\njim(\n jim(x, y, mag, \"|Sensitivity maps raw|\"; color=:cividis, ncol=1, prompt=false),\n jim(x, y, phase, \"∠(Sensitivity maps raw)\"; color=:hsv, ncol=1, prompt=false),\n)\n\nTypical sensitivity map estimation methods normalize the maps so that the square-root of the sum of squares (SSoS) is unity:\n\nssos = sqrt.(sum(abs.(smap).^2, dims=ndims(smap))) # SSoS\nssos = selectdim(ssos, ndims(smap), 1)\njim(x, y, ssos, \"SSoS for ncoil=$ncoil\"; color=:cividis, clim=(0,1))\n\nfor ic=1:ncoil # normalize\n    selectdim(smap, ndims(smap), ic) ./= ssos\nend\nsmap .*= mask\nstacker = x -> [(@view x[:,:,i]) for i=1:size(x,3)]\nsmaps = stacker(smap) # code hereafter expects vector of maps\njim(x, y, cfun(smaps), \"Sensitivity maps (masked and normalized)\")","category":"section"},{"location":"generated/examples/10-mri-sense/#Sensitivity-map-fitting-using-complex-exponentials","page":"MRI SENSE","title":"Sensitivity map fitting using complex exponentials","text":"The mri_smap_fit function fits each smap with a linear combination of complex exponential signals. (These signals are not orthogonal due to the mask.) With frequencies -9:9/N, the maximum error is ≤ 0.4%.\n\ndeltas = (dx, dy)\nkmax = 9\nfit = mri_smap_fit(smaps, embed; mask, kmax, deltas)\njim(\n jim(x, y, cfun(smaps), \"Original maps\"; prompt=false, clim=(-1,1)),\n jim(x, y, cfun(fit.smaps), \"Fit maps\"; prompt=false, clim=(-1,1)),\n jim(x, y, cfun(100 * (fit.smaps - smaps)), \"error * 100\"; prompt=false),\n)\n\nThe fit coefficients are smaller near ±kmax so probably kmax is large enough.\n\ncoefs = map(x -> reshape(x, 2kmax+1, 2kmax+1), fit.coefs)\njim(-kmax:kmax, -kmax:kmax, cfun(coefs), \"Coefficients\")","category":"section"},{"location":"generated/examples/10-mri-sense/#Compare-FFT-with-analytical-spectra","page":"MRI SENSE","title":"Compare FFT with analytical spectra","text":"Frequency sample vectors:\n\nfx = (-(nx÷2):(nx÷2-1)) / (nx*dx) # crucial to match `mri_smap_basis` internals!\nfy = (-(ny÷2):(ny÷2-1)) / (ny*dy)\ngx, gy = ndgrid(fx, fy);\nnothing #hide\n\nAnalytical spectra computation for complex phantom using all smaps. Note the fit argument.\n\nkspace1 = mri_spectra(vec(gx), vec(gy), oa, fit)\nkspace1 = [reshape(k, nx, ny) for k in kspace1]\np1 = jim(fx, fy, cfun(kspace1), \"Analytical\")\n\nFFT spectra computation based on digital image and sensitivity maps:\n\nimage2 = [image0 .* s for s in smaps] # digital\nkspace2 = myfft.(image2) * (dx * dy)\np2 = jim(fx, fy, cfun(kspace2), \"FFT-based\")\n\np3 = jim(fx, fy, cfun(kspace2 - kspace1), \"Error\")\n\nZoom in to illustrate similarity:\n\nxlims = (-1,1) .* (0.06/mm)\nylims = (-1,1) .* (0.06/mm)\njim(\n jim(fx, fy, real(kspace1[1]), \"Analytical\"; xlims, ylims, prompt=false),\n jim(fx, fy, real(kspace2[1]), \"FFT-based\"; xlims, ylims, prompt=false),\n jim(fx, fy, real(kspace2[1] - kspace1[1]), \"Error\"; xlims, ylims, prompt=false),\n)\n\nIn summary, the mri_smap_fit and mri_spectra methods here reproduce the approach in the 2012 Guerquin-Kern paper, cited above, enabling parallel MRI simulations that avoid an inverse crime.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/30-3d/#30-3d","page":"3D geometry","title":"3D geometry","text":"This page explains the 3D X-ray transform geometry for the Julia package ImagePhantoms.\n\nThis page comes from a single Julia file: 30-3d.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 30-3d.ipynb, or open it in binder here: 30-3d.ipynb.","category":"section"},{"location":"generated/examples/30-3d/#Setup","page":"3D geometry","title":"Setup","text":"Packages needed here.","category":"section"},{"location":"generated/examples/30-3d/#Overview","page":"3D geometry","title":"Overview","text":"Most practical tomographic imaging problems are 3D, so this package also supports calculating 3D line integrals through 3D phantom objects.","category":"section"},{"location":"generated/examples/30-3d/#3D-projection-geometry","page":"3D geometry","title":"3D projection geometry","text":"Given a 3D phantom object, the function radon returns a 4-argument function having arguments (uvϕθ), where uv denote the coordinates on a 2D projection plane, ϕ denotes the azimuthal angle angle and θ denotes the polar angle.\n\nThe mathematical definition of the Radon transform of a 3D function is a collection of (2D) plane integrals, whereas the X-ray transform is a collection of (1D) line integrals. See Section II.1, Natterer 2001. So strictly speaking the radon function is a misnomer in 3D, whereas for 2D functions the Radon transform and the X-ray transform coincide.\n\nThe coordinate system used here is defined as follows. Start by defining a point on the \"detector plane\" as follows:\n\nvecp = vecp(u v ϕ θ)\n= u vece_1 + v vece_3\n= (u cos ϕ + v sin ϕ sin θ u sin ϕ - v cos ϕ sin θ v cos θ)  ℝ^3\n\nwhere\n\nvece_1 = (cos ϕ sin ϕ 0)\nqquad\nvece_3 = (sin ϕ sin θ -cos ϕ sin θ cos θ)\n\nNow define the (X-ray) projection of a 3D object f(vecx) as\n\np(u v ϕ θ)\n=  f(vecp + ℓ  vece)  mathrmd ℓ\n= _-^ f( vecp(uvϕθ) + ℓ  vece(ϕθ) )  mathrmd ℓ\n\nwhere\n\nvece(ϕθ) = (-sin ϕ cos θ cos ϕ cos θ sin θ)\n\nWhen θ=0, then the X-ray transform p(u v ϕ θ) is a collection of 2D sinograms, one for each slice of f(xyz):\n\np(u v ϕ 0)\n= _-^ f(u cos ϕ - ℓ sin ϕ u sin ϕ + ℓ cos ϕ v)  mathrmd ℓ\n\nFor example projection views, see the Ellipsoid examples.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/33-cuboid/#33-cuboid","page":"Cuboid","title":"Cuboid","text":"This page illustrates the Cuboid shape in the Julia package ImagePhantoms.\n\nThis page comes from a single Julia file: 33-cuboid.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 33-cuboid.ipynb, or open it in binder here: 33-cuboid.ipynb.","category":"section"},{"location":"generated/examples/33-cuboid/#Setup","page":"Cuboid","title":"Setup","text":"Packages needed here.\n\nusing ImagePhantoms: Object, phantom, radon, spectrum\nusing ImagePhantoms: Cuboid, cuboid\nimport ImagePhantoms as IP\nusing ImageGeoms: ImageGeom, axesf\nusing MIRTjim: jim, prompt, mid3\nusing FFTW: fft, fftshift, ifftshift\nusing LazyGrids: ndgrid\nusing Unitful: mm, unit, °\nusing Plots: plot, plot!, scatter!, default\nusing Plots # gif @animate\ndefault(markerstrokecolor=:auto)\n\nThe following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/33-cuboid/#Overview","page":"Cuboid","title":"Overview","text":"A basic shape used in constructing 3D digital image phantoms is the 3D cuboid, specified by its center, width, angle(s) and value. All of the methods in ImagePhantoms support physical units, so we use such units throughout this example. (Using units is recommended but not required.)\n\nHere are 3 ways to define a 3D Object{Cuboid}, using physical units.\n\ncenter = (10mm, 8mm, 6mm)\nwidth = (35mm, 25mm, 15mm)\nϕ0s = :(π/6) # symbol version for nice plot titles\nϕ0 = eval(ϕ0s)\nangles = (ϕ0, 0, 0)\nObject(Cuboid(), center, width, angles, 1.0f0) # top-level constructor\ncuboid( 10mm, 8mm, 6mm, 35mm, 25mm, 15mm, π/6, 0, 0, 1.0f0 ) # 9 arguments\nob = cuboid(center, width, angles, 1.0f0) # tuples (recommended use)","category":"section"},{"location":"generated/examples/33-cuboid/#Phantom-image-using-phantom","page":"Cuboid","title":"Phantom image using phantom","text":"Make a 3D digital image of it using phantom and display it. We use ImageGeoms to simplify the indexing.\n\ndeltas = (1.0mm, 1.1mm, 1.2mm)\ndims = (2^8, 2^8+2, 49) # odd\nig = ImageGeom( ; dims, deltas, offsets=:dsp)\noversample = 3\nimg = phantom(axes(ig)..., [ob], oversample)\np1 = jim(axes(ig), img;\n   title=\"Cuboid, rotation ϕ=$ϕ0s\", xlabel=\"x\", ylabel=\"y\")\n\nThe image integral should match the object volume:\n\nvolume = IP.volume(ob)\n(sum(img)*prod(ig.deltas), volume)\n\nShow middle slices\n\njim(mid3(img), \"Middle 3 planes\")","category":"section"},{"location":"generated/examples/33-cuboid/#Spectrum-using-spectrum","page":"Cuboid","title":"Spectrum using spectrum","text":"There are two ways to examine the spectrum of this 3D image:\n\nusing the analytical Fourier transform of the object via spectrum\napplying the DFT via FFT to the digital image.\n\nBecause the shape has units mm, the spectra axes have units cycles/mm. Appropriate frequency axes for DFT are provided by axesf(ig).\n\nvscale = 1 / volume # normalize spectra by volume\nspectrum_exact = spectrum(axesf(ig)..., [ob]) * vscale\nsp = z -> max(log10(abs(z)/oneunit(abs(z))), -6) # log-scale for display\nclim = (-6, 0) # colorbar limit for display\n(xlabel, ylabel) = (\"ν₁\", \"ν₂\")\np2 = jim(axesf(ig), sp.(spectrum_exact), \"log10|Spectrum|\"; clim, xlabel, ylabel)\n\nSadly fft cannot handle units currently, so this function is a work-around:\n\nfunction myfft(x)\n    u = unit(eltype(x))\n    return fftshift(fft(ifftshift(x) / u)) * u\nend\n\nspectrum_fft = myfft(img) * (prod(ig.deltas) * vscale)\np3 = jim(axesf(ig), sp.(spectrum_fft), \"log10|DFT|\"; clim, xlabel, ylabel)\n\nCompare the DFT and analytical spectra to validate the code\n\nerrf = maximum(abs, spectrum_exact - spectrum_fft) / maximum(abs, spectrum_exact)\n@assert errf < 4e-2\np4 = jim(axesf(ig), 1e3*abs.(spectrum_fft - spectrum_exact);\n   title=\"|Difference| × 10³\", xlabel, ylabel)\njim(p1, p4, p2, p3)","category":"section"},{"location":"generated/examples/33-cuboid/#Parallel-beam-projections-using-radon","page":"Cuboid","title":"Parallel-beam projections using radon","text":"Compute 2D projection views of the object using radon. Validate it using the projection-slice theorem aka Fourier-slice theorem.\n\npg = ImageGeom((2^8,2^7), (0.6mm,1.0mm), (0.5,0.5)) # projection sampling\nϕs, θs = (:(π/3), ϕ0s), (:(π/7), :(0))\nϕ3 = ϕ0 + atan(ob.width[1], ob.width[2])\nθ3 = atan(ob.width[3], sqrt(sum(abs2, ob.width[1:2])))\nϕ, θ = [eval.(ϕs)..., ϕ3], [eval.(θs)..., θ3]\nproj3 = [radon(axes(pg)..., ϕ[i], θ[i], [ob]) for i in 1:3] # 3 projections\nsmax = ob.value * sqrt(sum(abs2, ob.width))\np5 = jim(axes(pg)..., proj3; xlabel=\"u\", ylabel=\"v\", nrow = 1, title =\n    \"Projections at (ϕ,θ) = ($(ϕs[1]), $(θs[1])) and ($(ϕs[2]), $(θs[2]))\\n\n    and along long axis\")\n\nBecause the object has maximum chord length of smax = sqrt(35^2+25^2+15^2) ≈ 45.6mm, and one of the views above was along the corresponding axis, the maximum projection value is about that value.\n\nmaxes = round.((smax, maximum.(proj3)...) ./ 1mm; digits=2)\n\nThe integral of each projection should match the object volume:\n\nvols = round.(((p -> sum(p)*prod(pg.deltas)).(proj3)..., volume) ./ 1mm^3; digits=2)\n\nLook at a set of projections as the views orbit around the object.\n\nϕd = 0:6:360\nϕs = deg2rad.(ϕd)\nθs = :(π/7)\nθ = eval(θs)\nprojs = radon(axes(pg)..., ϕs, [θ], [ob]) # many projection views\n\nif isinteractive()\n    jim(axes(pg)..., projs; title=\"projection views $(ϕd)\")\nelse\n    anim = @animate for ip in 1:length(ϕd)\n        jim(axes(pg), projs[:,:,ip,1]; xlabel=\"u\", ylabel=\"v\", prompt=false,\n            title=\"ϕ=$(ϕd[ip])° θ=$θs\", clim = (0,1) .* smax)\n    end\n    gif(anim, \"cuboid.gif\", fps = 6)\nend\n\nThe above sampling generated a parallel-beam projection, but one could make a cone-beam projection by sampling (u, v, ϕ, θ) appropriately. See Sinograms.jl.","category":"section"},{"location":"generated/examples/33-cuboid/#Fourier-slice-theorem-illustration","page":"Cuboid","title":"Fourier-slice theorem illustration","text":"Pick one particular view and compare its FFT to a slice through the 3D object spectrum.\n\nϕs, θs = :(π/3), :(π/7)\nϕ, θ = eval.((ϕs, θs))\nproj = radon(axes(pg)..., ϕ, θ, [ob])\np6 = jim(axes(pg), proj; xlabel=\"u\", ylabel=\"v\", prompt=false,\n    title = \"Projection at (ϕ,θ) = ($ϕs, $θs)\")\n\ne1 = (cos(ϕ), sin(ϕ), 0)\ne3 = (sin(ϕ)*sin(θ), -cos(ϕ)*sin(θ), cos(θ))\nfu, fv = ndgrid(axesf(pg)...)\nff = vec(fu) * [e1...]' + vec(fv) * [e3...]' # fx,fy,fz for Fourier-slice theorem\nspectrum_slice = spectrum(ob).(ff[:,1], ff[:,2], ff[:,3]) * vscale\nspectrum_slice = reshape(spectrum_slice, pg.dims)\nclim = (-6, 0) # colorbar limit for display\n(xlabel, ylabel) = (\"νᵤ\", \"νᵥ\")\np7 = jim(axesf(pg), sp.(spectrum_slice); prompt=false,\n    title = \"log10|Spectrum Slice|\", clim, xlabel, ylabel)\nproj_fft = myfft(proj) * prod(pg.deltas) * vscale\np8 = jim(axesf(pg), sp.(proj_fft); prompt=false,\n     title = \"log10|FFT Spectrum|\", clim, xlabel, ylabel)\n\nerrs = maximum(abs, spectrum_slice - proj_fft) / maximum(abs, spectrum_slice)\n@assert errs < 2e-3\np9 = jim(axesf(pg), 1e6*abs.(proj_fft - spectrum_slice);\n    title=\"|Difference| × 10⁶\", xlabel, ylabel, prompt=false)\njim(p6, p7, p8, p9)\n\nThe good agreement between the 2D slice through the 3D analytical spectrum and the FFT of the 2D projection view validates that phantom, radon, and spectrum are all self consistent for this shape.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/34-gauss3/#34-gauss3","page":"Gauss3","title":"Gauss3","text":"This page illustrates the Gauss3 shape in the Julia package ImagePhantoms.\n\nThis page comes from a single Julia file: 34-gauss3.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 34-gauss3.ipynb, or open it in binder here: 34-gauss3.ipynb.","category":"section"},{"location":"generated/examples/34-gauss3/#Setup","page":"Gauss3","title":"Setup","text":"Packages needed here.\n\nusing ImagePhantoms: Object, phantom, radon, spectrum\nusing ImagePhantoms: Gauss3, gauss3\nimport ImagePhantoms as IP\nusing ImageGeoms: ImageGeom, axesf\nusing MIRTjim: jim, prompt, mid3\nusing FFTW: fft, fftshift, ifftshift\nusing LazyGrids: ndgrid\nusing Unitful: mm, unit, °\nusing Plots: plot, plot!, scatter!, default\nusing Plots # gif @animate\ndefault(markerstrokecolor=:auto)\n\nThe following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/34-gauss3/#Overview","page":"Gauss3","title":"Overview","text":"A useful shape for constructing 3D digital image phantoms is the 3D gaussian, specified by its center, fwhm, angle(s) and value. All of the methods in ImagePhantoms support physical units, so we use such units throughout this example. (Using units is recommended but not required.)\n\nHere are 3 ways to define a 3D Object{Gauss3}, using physical units.\n\ncenter = (20mm, 10mm, 5mm)\nwidth = (25mm, 35mm, 15mm)\nϕ0s = :(π/6) # symbol version for nice plot titles\nϕ0 = eval(ϕ0s)\nangles = (ϕ0, 0, 0)\nObject(Gauss3(), center, width, angles, 1.0f0) # top-level constructor\ngauss3(20mm, 10mm, 5mm, 25mm, 35mm, 15mm, π/6, 0, 0, 1.0f0) # 9 arguments\nob = gauss3(center, width, angles, 1.0f0) # tuples (recommended use)","category":"section"},{"location":"generated/examples/34-gauss3/#Phantom-image-using-phantom","page":"Gauss3","title":"Phantom image using phantom","text":"Make a 3D digital image of it using phantom and display it. We use ImageGeoms to simplify the indexing.\n\ndeltas = (1.0mm, 1.1mm, 1.2mm)\ndims = (2^8, 2^8+2, 49) # odd\nig = ImageGeom( ; dims, deltas, offsets=:dsp)\noversample = 2\nimg = phantom(axes(ig)..., [ob], oversample)\np1 = jim(axes(ig), img;\n   title=\"Gauss3, rotation ϕ=$ϕ0s\", xlabel=\"x\", ylabel=\"y\")\n\nThe image integral should match the object volume:\n\nvolume = IP.volume(ob)\n(sum(img)*prod(ig.deltas), volume)\n\nShow middle slices\n\njim(mid3(img), \"Middle 3 planes\")","category":"section"},{"location":"generated/examples/34-gauss3/#Spectrum-using-spectrum","page":"Gauss3","title":"Spectrum using spectrum","text":"There are two ways to examine the spectrum of this 3D image:\n\nusing the analytical Fourier transform of the object via spectrum\napplying the DFT via FFT to the digital image.\n\nBecause the shape has units mm, the spectra axes have units cycles/mm. Appropriate frequency axes for DFT are provided by axesf(ig).\n\nvscale = 1 / volume # normalize spectra by volume\nspectrum_exact = spectrum(axesf(ig)..., [ob]) * vscale\nsp = z -> max(log10(abs(z)/oneunit(abs(z))), -6) # log-scale for display\nclim = (-6, 0) # colorbar limit for display\n(xlabel, ylabel) = (\"ν₁\", \"ν₂\")\np2 = jim(axesf(ig), sp.(spectrum_exact), \"log10|Spectrum|\"; clim, xlabel, ylabel)\n\nSadly fft cannot handle units currently, so this function is a work-around:\n\nfunction myfft(x)\n    u = unit(eltype(x))\n    return fftshift(fft(ifftshift(x) / u)) * u\nend\n\nspectrum_fft = myfft(img) * (prod(ig.deltas) * vscale)\np3 = jim(axesf(ig), sp.(spectrum_fft), \"log10|DFT|\"; clim, xlabel, ylabel)\n\nCompare the DFT and analytical spectra to validate the code\n\nerrf = maximum(abs, spectrum_exact - spectrum_fft) / maximum(abs, spectrum_exact)\n@assert errf < 1e-3\np4 = jim(axesf(ig), 1e3*abs.(spectrum_fft - spectrum_exact);\n   title=\"|Difference| × 10³\", xlabel, ylabel)\njim(p1, p4, p2, p3)","category":"section"},{"location":"generated/examples/34-gauss3/#Parallel-beam-projections-using-radon","page":"Gauss3","title":"Parallel-beam projections using radon","text":"Compute 2D projection views of the object using radon. Validate it using the projection-slice theorem aka Fourier-slice theorem.\n\npg = ImageGeom((2^8,2^7), (0.6mm,1.0mm), (0.5,0.5)) # projection sampling\nϕs, θs = (:(π/2), ϕ0s), (:(π/7), :(0))\nϕ, θ = [eval.(ϕs)...], [eval.(θs)...]\nproj2 = [radon(axes(pg)..., ϕ[i], θ[i], [ob]) for i in 1:2] # 2 projections\nsmax = ob.value * IP.fwhm2spread(maximum(ob.width))\np5 = jim(axes(pg)..., proj2; xlabel=\"u\", ylabel=\"v\", title =\n    \"Projections at (ϕ,θ) = ($(ϕs[1]), $(θs[1])) and ($(ϕs[2]), $(θs[2]))\")\n\nBecause the object has maximum FWHM of 35mm, and one of the two views above was along the corresponding axis, the maximum projection value is about fwhm2spread(35mm) = 35mm * sqrt(π / log(16)) ≈ 37.25mm.\n\nmaxes = round.((smax, maximum.(proj2)...) ./ 1mm; digits=2)\n\nThe integral of each projection should match the object volume:\n\nvols = round.(((p -> sum(p)*prod(pg.deltas)).(proj2)..., volume) ./ 1mm^3; digits=2)\n\nLook at a set of projections as the views orbit around the object.\n\nϕd = 0:6:360\nϕs = deg2rad.(ϕd)\nθs = :(π/7)\nθ = eval(θs)\nprojs = radon(axes(pg)..., ϕs, [θ], [ob]) # many projection views\n\nif isinteractive()\n    jim(axes(pg)..., projs; title=\"projection views $(ϕd)\")\nelse\n    anim = @animate for ip in 1:length(ϕd)\n        jim(axes(pg), projs[:,:,ip,1]; xlabel=\"u\", ylabel=\"v\", prompt=false,\n            title=\"ϕ=$(ϕd[ip])° θ=$θs\", clim = (0,1) .* smax)\n    end\n    gif(anim, \"gauss3.gif\", fps = 6)\nend\n\nThe above sampling generated a parallel-beam projection, but one could make a cone-beam projection by sampling (u, v, ϕ, θ) appropriately. See Sinograms.jl.","category":"section"},{"location":"generated/examples/34-gauss3/#Fourier-slice-theorem-illustration","page":"Gauss3","title":"Fourier-slice theorem illustration","text":"Pick one particular view and compare its FFT to a slice through the 3D object spectrum.\n\nϕs, θs = :(π/3), :(π/7)\nϕ, θ = eval.((ϕs, θs))\nproj = radon(axes(pg)..., ϕ, θ, [ob])\np6 = jim(axes(pg), proj; xlabel=\"u\", ylabel=\"v\", prompt=false,\n    title = \"Projection at (ϕ,θ) = ($ϕs, $θs)\")\n\ne1 = (cos(ϕ), sin(ϕ), 0)\ne3 = (sin(ϕ)*sin(θ), -cos(ϕ)*sin(θ), cos(θ))\nfu, fv = ndgrid(axesf(pg)...)\nff = vec(fu) * [e1...]' + vec(fv) * [e3...]' # fx,fy,fz for Fourier-slice theorem\nspectrum_slice = spectrum(ob).(ff[:,1], ff[:,2], ff[:,3]) * vscale\nspectrum_slice = reshape(spectrum_slice, pg.dims)\nclim = (-6, 0) # colorbar limit for display\n(xlabel, ylabel) = (\"νᵤ\", \"νᵥ\")\np7 = jim(axesf(pg), sp.(spectrum_slice); prompt=false,\n    title = \"log10|Spectrum Slice|\", clim, xlabel, ylabel)\nproj_fft = myfft(proj) * prod(pg.deltas) * vscale\np8 = jim(axesf(pg), sp.(proj_fft); prompt=false,\n     title = \"log10|FFT Spectrum|\", clim, xlabel, ylabel)\n\nerrs = maximum(abs, spectrum_slice - proj_fft) / maximum(abs, spectrum_slice)\n@assert errs < 1e-5\np9 = jim(axesf(pg), 1e6*abs.(proj_fft - spectrum_slice);\n    title=\"|Difference| × 10⁶\", xlabel, ylabel, prompt=false)\njim(p6, p7, p8, p9)\n\nThe good agreement between the 2D slice through the 3D analytical spectrum and the FFT of the 2D projection view validates that phantom, radon, and spectrum are all self consistent for this shape.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/35-cylinder/#35-cylinder","page":"Cylinder","title":"Cylinder","text":"This page illustrates the Cylinder shape in the Julia package ImagePhantoms.\n\nThis page comes from a single Julia file: 35-cylinder.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 35-cylinder.ipynb, or open it in binder here: 35-cylinder.ipynb.","category":"section"},{"location":"generated/examples/35-cylinder/#Setup","page":"Cylinder","title":"Setup","text":"Packages needed here.\n\nusing ImagePhantoms: Object, phantom, radon, spectrum\nusing ImagePhantoms: Cylinder, cylinder\nimport ImagePhantoms as IP\nusing ImageGeoms: ImageGeom, axesf\nusing MIRTjim: jim, prompt, mid3\nusing FFTW: fft, fftshift, ifftshift\nusing LazyGrids: ndgrid\nusing Unitful: mm, unit, °\nusing Plots: plot, plot!, scatter!, default\nusing Plots # gif @animate\ndefault(markerstrokecolor=:auto)\n\nThe following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/35-cylinder/#Overview","page":"Cylinder","title":"Overview","text":"A basic shape used in constructing 3D digital image phantoms is the cylinder, specified by its center, radii, height, angle(s) and value. All of the methods in ImagePhantoms support physical units, so we use such units throughout this example. (Using units is recommended but not required.)\n\nHere are 3 ways to define a Object{Cylinder}, using physical units.\n\ncenter = (20mm, 10mm, 5mm)\nwidth = (25mm, 35mm, 15mm) # x radius, y radius, height\nϕ0s = :(π/6) # symbol version for nice plot titles\nϕ0 = eval(ϕ0s)\nangles = (ϕ0, 0, 0)\nObject(Cylinder(), center, width, angles, 1.0f0) # top-level constructor\ncylinder( 20mm, 10mm, 5mm, 25mm, 35mm, 15mm, π/6, 0, 0, 1.0f0) # 9 arguments\nob = cylinder(center, width, angles, 1.0f0) # tuples (recommended use)","category":"section"},{"location":"generated/examples/35-cylinder/#Phantom-image-using-phantom","page":"Cylinder","title":"Phantom image using phantom","text":"Make a 3D digital image of it using phantom and display it. We use ImageGeoms to simplify the indexing.\n\ndeltas = (1.0mm, 1.1mm, 0.9mm)\ndims = (2^8, 2^8+2, 49) # odd\nig = ImageGeom( ; dims, deltas, offsets=:dsp)\noversample = 3\nimg = phantom(axes(ig)..., [ob], oversample)\np1 = jim(axes(ig), img;\n   title=\"Cylinder, rotation ϕ=$ϕ0s\", xlabel=\"x\", ylabel=\"y\")\n\nThe image integral should match the object volume:\n\nvolume = IP.volume(ob)\n(sum(img)*prod(ig.deltas), volume)\n\nShow middle slices\n\njim(mid3(img), \"Middle 3 planes\")","category":"section"},{"location":"generated/examples/35-cylinder/#Spectrum-using-spectrum","page":"Cylinder","title":"Spectrum using spectrum","text":"There are two ways to examine the spectrum of this 3D image:\n\nusing the analytical Fourier transform of the object via spectrum\napplying the DFT via FFT to the digital image.\n\nBecause the shape has units mm, the spectra axes have units cycles/mm. Appropriate frequency axes for DFT are provided by axesf(ig).\n\nvscale = 1 / volume # normalize spectra by volume\nspectrum_exact = spectrum(axesf(ig)..., [ob]) * vscale\nsp = z -> max(log10(abs(z)/oneunit(abs(z))), -6) # log-scale for display\nclim = (-6, 0) # colorbar limit for display\n(xlabel, ylabel) = (\"ν₁\", \"ν₂\")\np2 = jim(axesf(ig), sp.(spectrum_exact), \"log10|Spectrum|\"; clim, xlabel, ylabel)\n\nSadly fft cannot handle units currently, so this function is a work-around:\n\nfunction myfft(x)\n    u = unit(eltype(x))\n    return fftshift(fft(ifftshift(x) / u)) * u\nend\n\nspectrum_fft = myfft(img) * (prod(ig.deltas) * vscale)\np3 = jim(axesf(ig), sp.(spectrum_fft), \"log10|DFT|\"; clim, xlabel, ylabel)\n\nCompare the DFT and analytical spectra to validate the code\n\nerrf = maximum(abs, spectrum_exact - spectrum_fft) / maximum(abs, spectrum_exact)\n@assert errf < 4e-2\np4 = jim(axesf(ig), 1e3*abs.(spectrum_fft - spectrum_exact);\n   title=\"|Difference| × 10³\", xlabel, ylabel)\njim(p1, p4, p2, p3)","category":"section"},{"location":"generated/examples/35-cylinder/#Parallel-beam-projections-using-radon","page":"Cylinder","title":"Parallel-beam projections using radon","text":"Compute 2D projection views of the object using radon. Validate it using the projection-slice theorem aka Fourier-slice theorem.\n\npg = ImageGeom((2^8,2^7), (0.6mm,1.0mm), (0.5,0.5)) # projection sampling\nϕs, θs = (:(π/3), ϕ0s), (:(π/7), :(0))\nϕ3 = ϕ0\nθ3 = atan(ob.width[3]/2, maximum(ob.width[1:2]))\nϕ, θ = [eval.(ϕs)..., ϕ3], [eval.(θs)..., θ3]\nproj3 = [radon(axes(pg)..., ϕ[i], θ[i], [ob]) for i in 1:3] # 3 projections\nsmax = ob.value * sqrt(maximum(abs2, 2 .* ob.width[1:2]) + abs2(ob.width[3]))\np5 = jim(axes(pg)..., proj3; xlabel=\"u\", ylabel=\"v\", nrow = 1, title =\n    \"Projections at (ϕ,θ) = ($(ϕs[1]), $(θs[1])) and ($(ϕs[2]), $(θs[2]))\\n\n    and along long axis\")\n\nBecause the cylinder has maximum diameter of 70mm and height 15mm, and one of the two views above was along the corresponding axis, the maximum projection value is about sqrt(70^2 + 15^2) ≈ 71.6mm.\n\nmaxes = round.((smax, maximum.(proj3)...) ./ 1mm; digits=2)\n\nThe integral of each projection should match the object volume:\n\nvols = round.(((p -> sum(p)*prod(pg.deltas)).(proj3)..., volume) ./ 1mm^3; digits=2)\n\nLook at a set of projections as the views orbit around the object.\n\nϕd = 0:6:360\nϕs = deg2rad.(ϕd)\nθs = :(π/7)\nθ = eval(θs)\nprojs = radon(axes(pg)..., ϕs, [θ], [ob]) # many projection views\n\nif isinteractive()\n    jim(axes(pg)..., projs; title=\"projection views $(ϕd)\")\nelse\n    anim = @animate for ip in 1:length(ϕd)\n        jim(axes(pg), projs[:,:,ip,1]; xlabel=\"u\", ylabel=\"v\", prompt=false,\n            title=\"ϕ=$(ϕd[ip])° θ=$θs\", clim = (0,1) .* smax)\n    end\n    gif(anim, \"cylinder.gif\", fps = 6)\nend\n\nThe above sampling generated a parallel-beam projection, but one could make a cone-beam projection by sampling (u, v, ϕ, θ) appropriately. See Sinograms.jl.","category":"section"},{"location":"generated/examples/35-cylinder/#Fourier-slice-theorem-illustration","page":"Cylinder","title":"Fourier-slice theorem illustration","text":"Pick one particular view and compare its FFT to a slice through the 3D object spectrum.\n\nϕs, θs = :(π/3), :(π/7)\nϕ, θ = eval.((ϕs, θs))\nproj = radon(axes(pg)..., ϕ, θ, [ob])\np6 = jim(axes(pg), proj; xlabel=\"u\", ylabel=\"v\", prompt=false,\n    title = \"Projection at (ϕ,θ) = ($ϕs, $θs)\")\n\ne1 = (cos(ϕ), sin(ϕ), 0)\ne3 = (sin(ϕ)*sin(θ), -cos(ϕ)*sin(θ), cos(θ))\nfu, fv = ndgrid(axesf(pg)...)\nff = vec(fu) * [e1...]' + vec(fv) * [e3...]' # fx,fy,fz for Fourier-slice theorem\nspectrum_slice = spectrum(ob).(ff[:,1], ff[:,2], ff[:,3]) * vscale\nspectrum_slice = reshape(spectrum_slice, pg.dims)\nclim = (-6, 0) # colorbar limit for display\n(xlabel, ylabel) = (\"νᵤ\", \"νᵥ\")\np7 = jim(axesf(pg), sp.(spectrum_slice); prompt=false,\n    title = \"log10|Spectrum Slice|\", clim, xlabel, ylabel)\nproj_fft = myfft(proj) * prod(pg.deltas) * vscale\np8 = jim(axesf(pg), sp.(proj_fft); prompt=false,\n     title = \"log10|FFT Spectrum|\", clim, xlabel, ylabel)\n\nerrs = maximum(abs, spectrum_slice - proj_fft) / maximum(abs, spectrum_slice)\n@assert errs < 1e-3\np9 = jim(axesf(pg), 1e3*abs.(proj_fft - spectrum_slice);\n    title=\"|Difference| × 10³\", xlabel, ylabel, prompt=false)\njim(p6, p7, p8, p9)\n\nThe good agreement between the 2D slice through the 3D analytical spectrum and the FFT of the 2D projection view validates that phantom, radon, and spectrum are all self consistent for this shape.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/36-cone/#36-cone","page":"Cone","title":"Cone","text":"This page illustrates the Cone shape in the Julia package ImagePhantoms.\n\nThis page comes from a single Julia file: 36-cone.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 36-cone.ipynb, or open it in binder here: 36-cone.ipynb.","category":"section"},{"location":"generated/examples/36-cone/#Setup","page":"Cone","title":"Setup","text":"Packages needed here.\n\nusing ImagePhantoms: Object, phantom, radon, spectrum\nusing ImagePhantoms: Cone, cone\nimport ImagePhantoms as IP\nusing ImageGeoms: ImageGeom, axesf\nusing MIRTjim: jim, prompt, mid3\nusing FFTW: fft, fftshift, ifftshift\nusing LazyGrids: ndgrid\nusing Unitful: mm, unit, °\nusing Plots: plot, plot!, scatter!, default\nusing Plots # gif @animate\ndefault(markerstrokecolor=:auto)\n\nThe following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/36-cone/#Overview","page":"Cone","title":"Overview","text":"A basic shape used in constructing 3D digital image phantoms is the cone, specified by its center, base radii, height, angle(s) and value. All of the methods in ImagePhantoms support physical units, so we use such units throughout this example. (Using units is recommended but not required.)\n\nHere are 3 ways to define a Object{Cone}, using physical units.\n\ncenter = (20mm, 10mm, -15mm)\nwidth = (25mm, 30mm, 35mm) # x radius, y radius, height\nϕ0s = :(π/6) # symbol version for nice plot titles\nϕ0 = eval(ϕ0s)\nangles = (ϕ0, 0, 0)\nObject(Cone(), center, width, angles, 1.0f0) # top-level constructor\ncone( 20mm, 10mm, 5mm, 25mm, 35mm, 15mm, π/6, 0, 0, 1.0f0) # 9 arguments\nob = cone(center, width, angles, 1.0f0) # tuples (recommended use)","category":"section"},{"location":"generated/examples/36-cone/#Phantom-image-using-phantom","page":"Cone","title":"Phantom image using phantom","text":"Make a 3D digital image of it using phantom and display it. We use ImageGeoms to simplify the indexing.\n\ndeltas = (1.0mm, 1.1mm, 0.9mm)\ndims = (2^8, 2^8+2, 49) # odd\nig = ImageGeom( ; dims, deltas, offsets=:dsp)\noversample = 3\nimg = phantom(axes(ig)..., [ob], oversample)\np1 = jim(axes(ig), img;\n   title=\"Cone, rotation ϕ=$ϕ0s\", xlabel=\"x\", ylabel=\"y\")\n\nThe image integral should match the object volume:\n\nvolume = IP.volume(ob)\n(sum(img)*prod(ig.deltas), volume)\n\nShow middle slices\n\njim(mid3(img), \"Middle 3 planes\")\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"methods/#Methods-list","page":"Methods","title":"Methods list","text":"","category":"section"},{"location":"methods/#Methods-usage","page":"Methods","title":"Methods usage","text":"","category":"section"},{"location":"methods/#ImagePhantoms.AbstractShape","page":"Methods","title":"ImagePhantoms.AbstractShape","text":"AbstractShape{D}\n\nGeneric shape type for ImagePhantoms. The dimension D is likely 2 or 3, e.g., 2 for an Ellipse and 3 for an Ellipsoid.\n\n\n\n\n\n","category":"type"},{"location":"methods/#ImagePhantoms.Cone","page":"Methods","title":"ImagePhantoms.Cone","text":"Cone <: AbstractShape{3}\n\n\n\n\n\n","category":"type"},{"location":"methods/#ImagePhantoms.Cuboid","page":"Methods","title":"ImagePhantoms.Cuboid","text":"Cuboid <: AbstractShape{3}\n\n\n\n\n\n","category":"type"},{"location":"methods/#ImagePhantoms.Cylinder","page":"Methods","title":"ImagePhantoms.Cylinder","text":"Cylinder <: AbstractShape{3}\n\n\n\n\n\n","category":"type"},{"location":"methods/#ImagePhantoms.Dirac","page":"Methods","title":"ImagePhantoms.Dirac","text":"Dirac{D} <: AbstractShape{D}\n\n\n\n\n\n","category":"type"},{"location":"methods/#ImagePhantoms.Ellipse","page":"Methods","title":"ImagePhantoms.Ellipse","text":"Ellipse <: AbstractShape{2}\n\n\n\n\n\n","category":"type"},{"location":"methods/#ImagePhantoms.EllipsePhantomVersion","page":"Methods","title":"ImagePhantoms.EllipsePhantomVersion","text":"EllipsePhantomVersion\n\nParent type for different versions of ellipse phantoms:\n\nSheppLogan original CT version from Shepp&Logan paper\nSheppLoganEmis higher contrast version suitable for emission tomography\nSheppLoganBrainWeb integer index version based on brainweb\nSheppLoganToft higher contrast version from Toft, 1996\nSouthPark for fun\n\n\n\n\n\n","category":"type"},{"location":"methods/#ImagePhantoms.Ellipsoid","page":"Methods","title":"ImagePhantoms.Ellipsoid","text":"Ellipsoid <: AbstractShape{3}\n\n\n\n\n\n","category":"type"},{"location":"methods/#ImagePhantoms.Gauss2","page":"Methods","title":"ImagePhantoms.Gauss2","text":"Gauss2 <: AbstractShape{2}\n\n\n\n\n\n","category":"type"},{"location":"methods/#ImagePhantoms.Gauss3","page":"Methods","title":"ImagePhantoms.Gauss3","text":"Gauss3 <: AbstractShape{3}\n\n\n\n\n\n","category":"type"},{"location":"methods/#ImagePhantoms.Object","page":"Methods","title":"ImagePhantoms.Object","text":"Object(shape ; cx, cy, cz, wx=1, wy=wx, wz=wx, ϕ=0, θ=0, ψ=0, value=1)\n\n3D object constructor from values (without tuples).\n\n\n\n\n\n","category":"type"},{"location":"methods/#ImagePhantoms.Object-2","page":"Methods","title":"ImagePhantoms.Object","text":"Object(shape ; cx, cy, wx=1, wy=wx, ϕ=0, value=1)\n\n2D object constructor from values (without tuples).\n\n\n\n\n\n","category":"type"},{"location":"methods/#ImagePhantoms.Object-3","page":"Methods","title":"ImagePhantoms.Object","text":"Object{S, D, V, C, A, Da}(center, width, angle, value) <: AbstractObject\n    where {S <: AbstractShape, V <: Number, C,A <: RealU}\n\nGeneral container for 2D and 3D objects for defining image phantoms.\n\ncenter::NTuple{D,C} coordinates of \"center\" of this object\nwidth::NTuple{D,C} \"width\" along each axis (e.g., FWHM for Gauss, radii for Ellipse)\nangle::NTuple{D-1,A} angle of x' axis relative to x axis, in radians (or with units)\nvalue::V \"intensity\" value for this object\n\nExample\n\njulia> Object(Ellipse(), (0,0), (1,2), 0.0, 1//2)\nObject2d{Ellipse, Rational{Int64}, Int64, Float64, 1, Float64} (S, D, V, ...)\n center::NTuple{2,Int64} (0, 0)\n width::NTuple{2,Int64} (1, 2)\n angle::Tuple{Float64} (0.0,)\n value::Rational{Int64} 1//2\n\n\n\n\n\n","category":"type"},{"location":"methods/#ImagePhantoms.Object-Union{Tuple{AbstractShape{D}}, Tuple{D}, Tuple{AbstractShape{D}, NTuple{D, Number}}, Tuple{AbstractShape{D}, NTuple{D, Number}, NTuple{D, Number}}, Tuple{AbstractShape{D}, NTuple{D, Number}, NTuple{D, Number}, Union{Number, NTuple{Da, Number}} where Da}, Tuple{AbstractShape{D}, NTuple{D, Number}, NTuple{D, Number}, Union{Number, NTuple{Da, Number}} where Da, Number}} where D","page":"Methods","title":"ImagePhantoms.Object","text":"Object(shape, center=(0,…), width=(1,…), angle=(0,…), value=1)\nObject(shape ; center, width=(1,…), angle=(0,…), value=1)\n\nGeneral outer Object constructor from tuples, as either positional arguments or named keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.Object-Union{Tuple{Object{S, D}}, Tuple{Da}, Tuple{D}, Tuple{S}} where {S, D, Da}","page":"Methods","title":"ImagePhantoms.Object","text":"Object(ob::Object ; center, width, angle, value)\n\nMake a copy of Object ob, optionally modifying some values.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.Object2d","page":"Methods","title":"ImagePhantoms.Object2d","text":"Object2d{S,V,C} = Object{S,2,V,C} where {S <: AbstractShape, V,C <: Number}\n\nFor 2D objects\n\n\n\n\n\n","category":"type"},{"location":"methods/#ImagePhantoms.Object3d","page":"Methods","title":"ImagePhantoms.Object3d","text":"Object3d{S,V,C} = Object{S,3,V,C} where {S <: AbstractShape, V,C <: Number}\n\nFor 3D objects\n\n\n\n\n\n","category":"type"},{"location":"methods/#ImagePhantoms.Rect","page":"Methods","title":"ImagePhantoms.Rect","text":"Rect <: AbstractShape{2}\n\n\n\n\n\n","category":"type"},{"location":"methods/#ImagePhantoms.SheppLogan","page":"Methods","title":"ImagePhantoms.SheppLogan","text":"SheppLogan\n\nOriginal version from : Larry A Shepp, Benjamin F Logan, \"The Fourier reconstruction of a head section,\" IEEE Transactions on Nuclear Science, 21(3):21-42, June 1974. doi\n\nAlso in Kak and Slaney 1988 text, p. 255. doi\n\n\n\n\n\n","category":"type"},{"location":"methods/#ImagePhantoms.SheppLoganToft","page":"Methods","title":"ImagePhantoms.SheppLoganToft","text":"SheppLoganToft\n\nToft, Peter Aundal & Sørensen, John Aasted \"The Radon transform-theory and implementation,\" Technical University of Denmark (DTU), 1996. Page 201. https://files.openpdfs.org/1ra51GP6gJO.pdf\n\n\n\n\n\n","category":"type"},{"location":"methods/#Base.:*-Union{Tuple{S}, Tuple{Object{S}, Number}} where S","page":"Methods","title":"Base.:*","text":"(*)(ob::Object, x::Number)\n(*)(x::Number, ob::Object)\n\nScale object value by x.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.show-Union{Tuple{D}, Tuple{S}, Tuple{IO, MIME{Symbol(\"text/plain\")}, Object{S, D}}} where {S, D}","page":"Methods","title":"Base.show","text":"show(io::IO, ::MIME\"text/plain\", ob::Object)\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.Rxyz_inv-Tuple{Number, Number, Number, Vararg{Real, 6}}","page":"Methods","title":"ImagePhantoms.Rxyz_inv","text":"Rxyz_inv(x::RealU, y::RealU, z::RealU, ϕ::RealU, θ::RealU, ψ::RealU)\nRxyz_inv(x::RealU, y::RealU, sinϕ, sinθ, sinψ, cosϕ, cosθ, cosψ)\n\nMultiply Rz(-ϕ) * Ry(-θ) * Rx(-ψ) * [x, y, z] for 3D (inverse) rotation.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.Rxyz_mul-Tuple{Number, Number, Number, Vararg{Real, 6}}","page":"Methods","title":"ImagePhantoms.Rxyz_mul","text":"Rxyz_mul(x::RealU, y::RealU, z::RealU, ϕ::RealU, θ::RealU, ψ::RealU)\nRxyz_mul(x::RealU, y::RealU, sinϕ, sinθ, sinψ, cosϕ, cosθ, cosψ)\n\nMultiply Rx(ψ) * Ry(θ) * Rz(ϕ) * [x, y, z] for 3D rotation, where ψ, θ, ϕ denote rotation about x, y, z axes with right-hand rule.\n\nThis is the reverse order of z-y′-x″ in https://en.wikipedia.org/wiki/Rotationformalismsinthreedimensions#Eulerangles(z-y%E2%80%B2-x%E2%80%B3intrinsic)%E2%86%92rotationmatrix.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms._interval-Tuple{Real, Number}","page":"Methods","title":"ImagePhantoms._interval","text":"(lower, upper) = _interval(a, b)\n\nDetermine the interval [lower, upper] corresponding to the set {x : b ≤ a x} where a is unitless but b and x have same units.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.circle","page":"Methods","title":"ImagePhantoms.circle","text":"circle(x, y, r, v=1) (circle of radius `r` centered at `(x,y)`)\ncircle((x,y), r=1, v=1) ditto\ncircle(r, v=1) centered at origin\n\nConstruct circles as special cases of Ellipse.\n\n\n\n\n\n","category":"function"},{"location":"methods/#ImagePhantoms.cone-Tuple","page":"Methods","title":"ImagePhantoms.cone","text":"cone(cx, cy, cz, wx, wy, wz, Φ, Θ, value::Number)\ncone(center::NTuple{3,RealU}, width::NTuple{3,RealU}, angle::NTuple{3,RealU}, v)\n\nConstruct Object{Cone} from parameters; here width is the base radii for wx and wy and wz is the height.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.coords-Tuple{Object2d, Number, Number}","page":"Methods","title":"ImagePhantoms.coords","text":"coords(object::Object2d, x::RealU, y::RealU)\n\nPut coordinates (x,y) in canonical axes associated with object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.coords-Tuple{Object3d, Number, Number, Number}","page":"Methods","title":"ImagePhantoms.coords","text":"coords(object::Object3d, x::RealU, y::RealU, y::RealU)\n\nPut coordinates (x,y,z) in canonical axes associated with object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.cube","page":"Methods","title":"ImagePhantoms.cube","text":"cube(x, y, z, w, v=1) (cube of width `w` centered at `(x,y,z)`)\ncube((x,y,z), w, v=1) ditto\ncube(w, v=1) centered at origin\n\nConstruct cubes as special cases of Cuboid.\n\n\n\n\n\n","category":"function"},{"location":"methods/#ImagePhantoms.cube_bounds-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractFloat","page":"Methods","title":"ImagePhantoms.cube_bounds","text":"(ℓmin, ℓmax) = cube_bounds(p, e)\n\nBounds of ℓ corresponding to rect(x) for direction e from point p.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.cuboid-Tuple","page":"Methods","title":"ImagePhantoms.cuboid","text":"cuboid(cx, cy, cz, wx, wy, wz, Φ, Θ, value::Number)\ncuboid(center::NTuple{3,RealU}, width::NTuple{3,RealU}, angle::NTuple{3,RealU}, v)\n\nConstruct Object{Cuboid} from parameters; here width is the full-width.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.cylinder-Tuple","page":"Methods","title":"ImagePhantoms.cylinder","text":"cylinder(cx, cy, cz, wx, wy, wz, Φ, Θ, value::Number)\ncylinder(center::NTuple{3,RealU}, width::NTuple{3,RealU}, angle::NTuple{3,RealU}, v)\n\nConstruct Object{Cylinder} from parameters; here width is the radius in x,y and the height in z.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.dirac2-Tuple","page":"Methods","title":"ImagePhantoms.dirac2","text":"dirac2(...)\n\nConstruct Object2d{Dirac2} from parameters; here width is a scale factor: δ((x - c)/w) = w * δ(x - c).\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.dirac3-Tuple","page":"Methods","title":"ImagePhantoms.dirac3","text":"dirac3(...)\n\nConstruct Object3d{Dirac3} from parameters; here width is a scale factor: δ((x - c)/w) = w * δ(x - c).\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.disk_phantom_params-Tuple{}","page":"Methods","title":"ImagePhantoms.disk_phantom_params","text":"params = disk_phantom_params( ; ...)\n\nGenerate ndisk ellipse phantom parameter 6-tuples for a head-sized disk plus many disks within it, designed so that the disks have some minimum separation minsep to avoid overlap and to simplify patch-based model fitting.\n\nOptions\n\nfov::Real = 240 image field of view in mm\nrhead::Function = () -> 100 background radius for \"head\" [mm]\nmuhead::Function = () -> 1000 \"μ\" (intensity) value for background head disk\nrdisk::Function = () -> 10 + 10 * rand() random disk radii [10,20]\nmudisk::Function = () -> 100 + 200 * rand() \"μ\" values for disks [100,300]\nndisk::Function = () -> 10 # of random disks\nminsep::Real = 8 minimum disk separation in mm\nmaxtry::Int = 500 give up on adding more disks if this is reached\nwarn::Bool = false warn if maxtry reached?\nseed::Int = 0 if nonzero then use this seed\n\nThe function options can be replaced with rand() for other Distributions.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.ellipse-Tuple","page":"Methods","title":"ImagePhantoms.ellipse","text":"ellipse(cx, cy, rx=1, ry=rx, ϕ=0, value::Number=1)\nellipse(center::NTuple{2,RealU}, radii::NTuple{2,RealU}=(1,1), ϕ::RealU=0, v=1)\n\nConstruct Object{Ellipse} from parameters.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.ellipse-Tuple{Vector{<:Tuple}}","page":"Methods","title":"ImagePhantoms.ellipse","text":"phantom = ellipse(Vector{Tuple{6 params}})\n\nReturn vector of Object{Ellipse}, one for each element of input vector of tuples. Often the input comes from ellipse_parameters.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.ellipse_parameters","page":"Methods","title":"ImagePhantoms.ellipse_parameters","text":"ellipse_parameters(case; fovs::NTuple{2}, u::NTuple{3}, disjoint::Bool)\n\nReturn vector of Tuples of ellipse parameters. By default the first four elements of each tuple are unitless \"fractions of field of view\", so elements 1,3 are scaled by xfov and elements 2,4 are scaled by yfov, where (xfov, yfov) = fovs. The optional 3-tuple u specifies scaling and/or units:\n\nelements 1-4 (center, radii) are scaled by u[1] (e.g., mm),\nelements 5 (angle) is scaled by u[2] (e.g., 1 or °),\nelements 6 (value) is scaled by u[3] (e.g., 1/cm) for an attenuation map.\n\nIf disjoint==true then the middle ellipse positions are adjusted to avoid overlap.\n\n\n\n\n\n","category":"function"},{"location":"methods/#ImagePhantoms.ellipse_parameters-Tuple{SouthPark}","page":"Methods","title":"ImagePhantoms.ellipse_parameters","text":"params = ellipse_parameters(SouthPark() ; fovs::NTuple{2,Number} = (100,100))\n\nEllipse parameters for \"South Park\" phantom.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.ellipse_parameters_shepplogan-Tuple{}","page":"Methods","title":"ImagePhantoms.ellipse_parameters_shepplogan","text":"ellipse_parameters_shepplogan( ; disjoint::Bool)\n\n10 × 6 Matrix{Float64} of classic Shepp-Logan ellipse parameters. If disjoint==true then the middle ellipse positions are adjusted to avoid overlap.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.ellipse_parameters_uscale-Union{Tuple{Tv}, Tuple{Ta}, Tuple{Tc}, Tuple{Tf}, Tuple{Tp}, Tuple{Matrix{Tp}, Tuple{Tf, Tf}, Tc, Ta, Tv}} where {Tp<:AbstractFloat, Tf<:Number, Tc<:Number, Ta<:Number, Tv<:Number}","page":"Methods","title":"ImagePhantoms.ellipse_parameters_uscale","text":"ellipse_parameters_uscale(params, fovs, uc, ua, uv)\n\nReturn vector of Tuples after FOV and unit scaling.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.ellipsoid-Tuple","page":"Methods","title":"ImagePhantoms.ellipsoid","text":"ellipsoid(cx, cy, cz, rx=1, ry=1, rz=1, Φ=0, Θ=0, value::Number = 1)\nellipsoid(center::NTuple{3,RealU}, radii::NTuple{3,RealU}, angle::NTuple{3,RealU}, v)\n\nConstruct Object{Ellipsoid} from parameters.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.ellipsoid-Tuple{Vector{<:Tuple}}","page":"Methods","title":"ImagePhantoms.ellipsoid","text":"oa = ellipsoid(Vector{Tuple{10 params}})\n\nReturn vector of Object{Ellipsoid}, one for each element of input vector of tuples. Often the input comes from ellipsoid_parameters.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.ellipsoid_parameters","page":"Methods","title":"ImagePhantoms.ellipsoid_parameters","text":"ellipsoid_parameters(case; fovs::NTuple{3}, u::NTuple{3})\n\nReturn vector of Tuples of ellipsoid parameters. By default the parameters are for a 3D Shepp-Logan ellipsoid phantom. By default the first 6 elements of each tuple are unitless \"fractions of field of view\", so elements 1,4 are scaled by xfov and elements 2,5 are scaled by yfov, and elements 3,6 are scaled by zfov, where (xfov, yfov, zfov) = fovs. The optional 3-tuple u specifies scaling and/or units:\n\nelements 1-6 (center, radii) are scaled by u[1] (e.g., mm),\nelements 7-8 (angles) are scaled by u[2] (e.g., 1 or °),\nelement 9 (value) is scaled by u[3] (e.g., 1/cm) for an attenuation map.\n\n\n\n\n\n","category":"function"},{"location":"methods/#ImagePhantoms.ellipsoid_parameters_shepplogan-Tuple{}","page":"Methods","title":"ImagePhantoms.ellipsoid_parameters_shepplogan","text":"ellipsoid_parameters_shepplogan( ; disjoint::Bool)\n\n12 × 10 Matrix{Float64} of 3D Shepp-Logan ellipsoid parameters (cx,cy,cz, rx,ry rz, Φ,Θ=0,Ψ=0, ρ). By default the first 6 columns are unitless \"fractions of field of view\".\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.ellipsoid_parameters_uscale-Union{Tuple{Tv}, Tuple{Ta}, Tuple{Tc}, Tuple{Tf}, Tuple{Tp}, Tuple{Matrix{Tp}, Tuple{Tf, Tf, Tf}, Tc, Ta, Tv}} where {Tp<:AbstractFloat, Tf<:Number, Tc<:Number, Ta<:Number, Tv<:Number}","page":"Methods","title":"ImagePhantoms.ellipsoid_parameters_uscale","text":"ellipsoid_parameters_uscale(params, fovs, uc, ua, uv)\n\nReturn vector of Tuples after FOV and unit scaling.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.focus_chart-Tuple{}","page":"Methods","title":"ImagePhantoms.focus_chart","text":"focus_chart( ; radius=1, nspoke=30, value=1)\n\nGenerate nspoke Triangle phantom parameters for a focus chart. Returns Vector{Object2d{Triangle} for passing to phantom.\n\nOptions\n\nradius::RealU = 1 radius of phantom\nnspoke::Int = 60 # of spokes\nvalue::Number = 1 alternate between 0 and this value\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.fwhm2spread-Tuple{Any}","page":"Methods","title":"ImagePhantoms.fwhm2spread","text":"s = fwhm2spread(w)\n\nConvert FWHM w to equivalent Gaussian spread s for exp(-π (xs)^2). exp(-π (fwhm/2/s)^2) = 1/2 means fwhm/2/s) = sqrt(log(2)/π) 2s/fwhm = sqrt(π/log(2)) 2s = fwhm * sqrt(π/log(2)) s = fwhm * sqrt(π / log(16))\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.gauss2-Tuple","page":"Methods","title":"ImagePhantoms.gauss2","text":"gauss2(cx, cy, wx, wy=wx, ϕ=0, value::Number=1)\ngauss2(center::NTuple{2,RealU}, width::NTuple{2,RealU}=(1,1), ϕ::RealU=0, v=1)\ngauss2(w, v=1) (isotropic of width `w`)\n\nConstruct Object{Gauss2} from parameters; here width = FWHM (full-width at half-maximum).\n\nIn 1D, the formula is g(x) = exp(-π ((x - cx) / sx)^2) where sx = fwhm2spread(w) = w * sqrt(π / log(16)), which, for cx=0,  has 1D FT G(ν) = sx^2 exp(π (sx νx)^2).\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.gauss3-Tuple","page":"Methods","title":"ImagePhantoms.gauss3","text":"gauss3(cx, cy, cz, wx, wy, wz, Φ=0, Θ=0, value::Number = 1)\ngauss3(center::NTuple{3,RealU}, radii::NTuple{3,RealU}=(1,1,1), angle::NTuple{2,RealU}=(0,0), v=1)\ngauss3(r, v=1) (isotropic of width `w`)\n\nConstruct Object{Gauss3} from parameters; here width = FWHM (full-width at half-maximum).\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.jinc-Tuple{X} where X<:Real","page":"Methods","title":"ImagePhantoms.jinc","text":"jinc(x)\n\nReturn jinc(x) = J1(π*x)/(2x), where J1 is a Bessel function of the first kind.\n\nThe argument x must be unitless.\n\nnote: Note\nSpecialFunctions.jinc(0) = 1 whereas the convention here is jinc(0) = π / 4 which corresponds to the area of a disk of unit diameter.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.mri_smap_basis-Union{Tuple{AbstractArray{Bool, D}}, Tuple{D}} where D","page":"Methods","title":"ImagePhantoms.mri_smap_basis","text":"mrismapbasis(mask ; kmax, kt, ki)\n\nConstruct Fourier basis for representing MRI sensitivity maps in terms of separable complex exponential signals, products of of the form basis = (k,N) -> exp.(2im * π * nfun(N) * kfun(k,N)). The default is nfun(N) = -(N÷2):(N÷2)-1 which is suitable for even N only. The default is kfun(k,N) = k / 2N, which is DCT-II like frequencies, leading to better boundary behavior than the DFT frequencies k/N.\n\nInput\n\nmask::AbstractArray{Bool,D} binary support mask for region to reconstruct\n\nOption\n\nkmax::Int = 5 default frequency index -kmax:kmax in all dimensions\nkfun::Function = (k,N) -> k / (2N) # DCT-II frequency\ndeltas::NTuple{D,<:Number} = ones(D) pixel sizes\n\n(For additional options kmaxs, kt, ki, T, see code.)\n\nOutput\n\n(; B, ν) where B is basis matrix of size count(mask) × nk where typically nk = (2*kmax+1)^D and ν is nk frequency tuples; each tuple has form ν = kfun.(Tuple(k), size(mask)) ./ deltas.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.mri_smap_fit-Union{Tuple{D}, Tuple{Vector{<:AbstractArray{<:Number, D}}, Function}} where D","page":"Methods","title":"ImagePhantoms.mri_smap_fit","text":"mri_smap_fit(smaps, embed ; mask, kwargs...)\n\nFit MRI sensitivity maps smaps using mri_smap_basis(mask ; kwargs...). Caller provides ImageGeoms.embed or equivalent.\n\nReturn named tuple (B, ν, coefs, nrmse, smaps):\n\n(B, ν) from mri_smap_basis\ncoefs::Vector : [ncoil] each of length nk\nnrmse::Real : smaps vs smaps_fit\nsmaps::Vector{Array{D}} : smaps_fit\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.mri_spectra-Tuple{AbstractVector, AbstractVector, Array{<:Object2d}, NamedTuple}","page":"Methods","title":"ImagePhantoms.mri_spectra","text":"mri_spectra(fx, fy, oa::Array{<:Object2d}, fit::NamedTuple)\n\nVersion of spectrum suitable for parallel MRI with sensitivity maps that were fit previously using mri_smap_fit. Returns a Vector of ncoil kspace data Vectors of dimension length(fx)\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.phantom-Tuple{AbstractVector, AbstractVector, AbstractVector, Array{<:Object3d}}","page":"Methods","title":"ImagePhantoms.phantom","text":"phantom(x::Vector, y::Vector, z::Vector, oa::Array{<:Object3d})\n\nReturn a 3D digital image of the phantom sampled at grid of (x,y,z) locations. Returned 3D image size is length(x) × length(y) × length(z).\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.phantom-Tuple{AbstractVector, AbstractVector, Array{<:Object2d}, Int64}","page":"Methods","title":"ImagePhantoms.phantom","text":"phantom(x::Vector, y::Vector, oa::Array{<:Object2d}, oversample::Int; T)\n\nReturn a 2D digital image of the phantom sampled at grid of (x,y) locations, with over-sampling factor oversample and element type T.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.phantom-Tuple{AbstractVector, AbstractVector, Array{<:Object2d}}","page":"Methods","title":"ImagePhantoms.phantom","text":"phantom(x::Vector, y::Vector, oa::Array{<:Object2d})\n\nReturn a 2D digital image of the phantom sampled at grid of (x,y) locations. Returned 2D image size is length(x) × length(y).\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.phantom-Tuple{Any, Array{<:Object}}","page":"Methods","title":"ImagePhantoms.phantom","text":"phantom(itr, oa::Array{<:Object})\n\nReturn phantom values sampled at locations returned by generator (or iterator) itr. Returned array size matches size(itr).\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.phantom-Tuple{Array{<:Object2d}}","page":"Methods","title":"ImagePhantoms.phantom","text":"phantom(oa::Array{<:Object2d})::Function\n\nReturn function of (x,y) that user can sample at any locations to make a 2D phantom image for an Array of 2D objects.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.phantom-Tuple{Array{<:Object3d}}","page":"Methods","title":"ImagePhantoms.phantom","text":"phantom(oa::Array{<:Object3d})::Function\n\nReturn function of (x,y,z) that user can sample at any locations to make a 3D phantom image for an Array of 3D objects.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.phantom-Tuple{Object2d}","page":"Methods","title":"ImagePhantoms.phantom","text":"phantom(ob::Object2d)::Function\n\nReturn function of (x,y) that user can sample at any locations to make a 2D phantom image for a single 2D object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.phantom-Tuple{Object3d}","page":"Methods","title":"ImagePhantoms.phantom","text":"phantom(ob::Object3d)::Function\n\nReturn function of (x,y,z) that user can sample at any locations to make a 3D phantom image for a single 3D object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.phantom-Union{Tuple{V}, Tuple{S}, Tuple{AbstractVector, AbstractVector, AbstractVector, Array{<:Object3d{S, V}}, Int64}} where {S, V<:Number}","page":"Methods","title":"ImagePhantoms.phantom","text":"image = phantom(x, y, z, oa::Array{<:Object3d}, oversample::Int; T)\n\nReturn a 3D digital image of the phantom sampled at grid of (x,y,z) locations, with over-sampling factor oversample and element type T.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.phantom1-Tuple{Object2d{Ellipse}, Tuple{Real, Real}}","page":"Methods","title":"ImagePhantoms.phantom1","text":"phantom1(ob::Object2d{Ellipse}, (x,y))\n\nEvaluate unit circle at (x,y), for unitless coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.phantom1-Tuple{Object2d{Gauss2}, Tuple{Real, Real}}","page":"Methods","title":"ImagePhantoms.phantom1","text":"phantom1(ob::Object2d{Gauss2}, (x,y))\n\nEvaluate unit gauss2 at (x,y), for unitless coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.phantom1-Tuple{Object2d{Rect}, Tuple{Real, Real}}","page":"Methods","title":"ImagePhantoms.phantom1","text":"phantom1(ob::Object2d{Rect}, (x,y))\n\nEvaluate unit square at (x,y), for unitless coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.phantom1-Tuple{Object2d{Triangle}, Tuple{Real, Real}}","page":"Methods","title":"ImagePhantoms.phantom1","text":"phantom1(ob::Object2d{Triangle}, (x,y))\n\nEvaluate unit triangle at (x,y), for unitless coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.phantom1-Tuple{Object3d{Cone}, Tuple{Real, Real, Real}}","page":"Methods","title":"ImagePhantoms.phantom1","text":"phantom1(ob::Object3d{Cone}, (x,y,z))\n\nEvaluate unit cone at (x,y,z), for unitless coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.phantom1-Tuple{Object3d{Cuboid}, Tuple{Real, Real, Real}}","page":"Methods","title":"ImagePhantoms.phantom1","text":"phantom1(ob::Object3d{Cuboid}, (x,y,z))\n\nEvaluate unit cube at (x,y,z), for unitless coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.phantom1-Tuple{Object3d{Cylinder}, Tuple{Real, Real, Real}}","page":"Methods","title":"ImagePhantoms.phantom1","text":"phantom1(ob::Object3d{Cylinder}, (x,y,z))\n\nEvaluate unit cylinder at (x,y,z), for unitless coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.phantom1-Tuple{Object3d{Ellipsoid}, Tuple{Real, Real, Real}}","page":"Methods","title":"ImagePhantoms.phantom1","text":"phantom1(ob::Object3d{Ellipsoid}, (x,y,z))\n\nEvaluate unit sphere at (x,y,z), for unitless coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.phantom1-Tuple{Object3d{Gauss3}, Tuple{Real, Real, Real}}","page":"Methods","title":"ImagePhantoms.phantom1","text":"phantom1(ob::Object3d{Gauss3}, (x,y,z))\n\nEvaluate Gauss3 (x,y,z), for unitless coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.radon-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, Array{<:Object3d}}","page":"Methods","title":"ImagePhantoms.radon","text":"radon(u:Vector, v:Vector, ϕ:Vector, θ:Vector, oa::Array{<:Object3d})\n\nReturn parallel-beam projections sampled at grid of (u,v,ϕ,θ) locations. Returned array size is length(u) × length(v) × length(ϕ) × length(θ).\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.radon-Tuple{AbstractVector, AbstractVector, Array{<:Object2d}}","page":"Methods","title":"ImagePhantoms.radon","text":"radon(r::Vector, ϕ::Vector, oa::Array{<:Object2d})\n\nReturn parallel-beam 2D sinogram sampled at grid of (r,ϕ) locations. Returned array size is length(r) × length(ϕ).\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.radon-Tuple{AbstractVector, AbstractVector, Number, Number, Array{<:Object3d}}","page":"Methods","title":"ImagePhantoms.radon","text":"radon(u:Vector, v:Vector, ϕ:RealU, θ:RealU, oa::Array{<:Object3d})\n\nReturn parallel-beam projection view sampled at grid of (u,v) locations for a given (ϕ,θ) pair. Returned array size is length(u) × length(v).\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.radon-Tuple{AbstractVector, Number, Array{<:Object2d}}","page":"Methods","title":"ImagePhantoms.radon","text":"radon(r::Vector, ϕ::RealU, oa::Array{<:Object2d})\n\nReturn parallel-beam projection sampled at grid of r locations for one ϕ value. Returned array size is length(r).\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.radon-Tuple{Any, Array{<:Object}}","page":"Methods","title":"ImagePhantoms.radon","text":"radon(itr, oa::Array{<:Object})\n\nReturn parallel-beam projections sampled at locations returned by generator (or iterator) itr. Returned array size matches size(itr).\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.radon-Tuple{Array{<:Object2d}}","page":"Methods","title":"ImagePhantoms.radon","text":"radon(oa::Array{<:Object2d})::Function\n\nReturn function of (r,ϕ) that user can sample at any sinogram coordinates to make a phantom 2D sinogram for an array of 3D objects.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.radon-Tuple{Array{<:Object3d}}","page":"Methods","title":"ImagePhantoms.radon","text":"radon(oa::Array{<:Object3d})::Function\n\nReturn function of (u,v,ϕ,θ) that user can sample at any projection coordinates to make projection views for an array of 3D objects.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.radon-Tuple{Object2d}","page":"Methods","title":"ImagePhantoms.radon","text":"radon(ob::Object2d)::Function\n\nReturn function of (r,ϕ) that user can sample at any projection coordinates to make sinogram views of a 2D object.\n\nThe coordinate system used here is such that ϕ=0 corresponds to line integrals along the y axis for an object f(xy). Then as ϕ increases, the line integrals rotate counter-clockwise.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.radon-Union{Tuple{Object3d{S}}, Tuple{S}} where S","page":"Methods","title":"ImagePhantoms.radon","text":"radon(ob::Object3d)::Function\n\nReturn function of (u,v,ϕ,θ) that user can sample at any projection coordinates to make projection views of a 3D object.\n\nThe coordinate system used here is such that ϕ=0 corresponds to line integrals along the y axis for an object f(xyz). Then as ϕ increases, the line integrals rotate counter-clockwise.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.radon_tri-Tuple{Any, Any, Any}","page":"Methods","title":"ImagePhantoms.radon_tri","text":"radon_tri(r, sinϕ, cosϕ)\n\nFor a line integral at radial position r and angle ϕ, the locus of points along the line is {(r cos(ϕ), r sin(ϕ)) + τ (-sin(ϕ), cos(ϕ)) : τ ∈ ℝ}. This function treats the equilateral triangle with base [-1/2,1/2], pointing upwards, as the intersection of three half planes:\n\nH0 = {(x,y) : y ≥ 0}\nH1 = y ≤ √3 (1/2 - x)\nH2 = y ≤ √3 (1/2 + x).\n\nFind the τ values where the line locus lies in each half planes, then take the length of the intersection of those three intervals.\n\nFor example, for H1 we have r sin(ϕ) + τ cos(ϕ) ≤ √3 (1/2 - (r cos(ϕ) - τ sin(ϕ))) or equivalently r (sin(ϕ) + √3 cos(ϕ)) - √3/2 ≤ τ (√3 sin(ϕ) - cos(ϕ)) which is a set the form b1 ≤ a1 τ, corresponding to some interval (l1,u1). Similarly for H0 and H2.\n\nThis approach might not be the most efficient, but it is simple.\n\nSee Peter Aundal Toft, \"The Radon transform - theory and implementation\", 1996 https://orbit.dtu.dk/en/publications/the-radon-transform-theory-and-implementation for a different approach to finding the Radon transform of a triangle.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.radon_type-Union{Tuple{Object{S, D, V, C, A}}, Tuple{A}, Tuple{C}, Tuple{V}, Tuple{D}, Tuple{S}} where {S, D, V<:Number, C<:Number, A<:Number}","page":"Methods","title":"ImagePhantoms.radon_type","text":"radon_type(::Object)\n\nDetermine the element type of the Radon transform of an object (including units if applicable). Ensures that its precision is at least Float32.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.rect-Tuple","page":"Methods","title":"ImagePhantoms.rect","text":"rect(cx, cy, wx=1, wy=wx, ϕ=0, value::Number=1)\nrect(center::NTuple{2,RealU}, width::NTuple{2,RealU}=(1,1), ϕ::RealU=0, v=1)\n\nConstruct Object{Rect} from parameters; here width is the full-width.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.rotate-Union{Tuple{S}, Tuple{Object2d{S}, Number}} where S","page":"Methods","title":"ImagePhantoms.rotate","text":"rotate(ob::Object2d, θ::RealU)\n\nRotate a 2D object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.rotate-Union{Tuple{S}, Tuple{Object3d{S}, Tuple{Number, Number, Number}}} where S","page":"Methods","title":"ImagePhantoms.rotate","text":"rotate(ob::Object3d, (α,β))\nrotate(ob::Object3d, α, β=0)\n\nRotate a 3D object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.scale-Union{Tuple{D}, Tuple{S}, Tuple{Object{S, D}, NTuple{D, Number}}} where {S, D}","page":"Methods","title":"ImagePhantoms.scale","text":"scale(ob::Object, factor::RealU)\nscale(ob::Object, factor::NTuple{D,RealU})\n\nScale the width(s) by factor.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.shepp_logan-Tuple{Int64, Int64, ImagePhantoms.EllipsePhantomVersion}","page":"Methods","title":"ImagePhantoms.shepp_logan","text":"image = shepp_logan(M, [N,] [case] ; options...)\n\nConvenience method for generating M×N samples of Shepp-Logan phantoms.\n\nIn\n\nM::Int : horizontal size\nN::Int : vertical size, defaults to M\ncase::EllipsePhantomVersion = SheppLogan()\n\nOptions\n\noversample::Int = 3 (usually)\nyflip::Bool = true (reverse y samples for convenience.)\nT::Type{<:Number} default Float32 (except Int for BrainWeb version)\nkwargs... remaining options passed to ellipse_parameters for parameters.\n\nOut\n\nimage : M × N matrix\n\nThe default here is 3× over-sampling along both axes (9 samples per pixel), except for the SheppLoganBrainWeb phantom that consists of integer indices.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.shepp_logan_values-Tuple{SheppLogan}","page":"Methods","title":"ImagePhantoms.shepp_logan_values","text":"values = shepp_logan_values(::EllipsePhantomVersion)\n\nReturn 10 Shepp-Logan ellipse amplitudes for various versions.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum-Tuple{AbstractVector, AbstractVector, AbstractVector, Array{<:Object3d}}","page":"Methods","title":"ImagePhantoms.spectrum","text":"spectrum(fx::Vector, fy::Vector, fz::Vector, oa::Array{<:Object3d})\n\nReturn 3D k-space array sampled at grid of (fx,fy,fz) locations. Returned 3D array size is length(fx) × length(fy) × length(fz).\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum-Tuple{AbstractVector, AbstractVector, Array{<:Object2d}}","page":"Methods","title":"ImagePhantoms.spectrum","text":"spectrum(fx:Vector, fy:Vector, oa::Array{<:Object2d})\n\nReturn 2D k-space array sampled at grid of (fx,fy) locations. Returned 2D array size is length(fx) × length(fy).\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum-Tuple{Any, Array{<:Object}}","page":"Methods","title":"ImagePhantoms.spectrum","text":"spectrum(itr, oa::Array{<:Object})\n\nReturn spectrum of object(s) sampled at k-space locations returned by generator (or iterator) itr. Returned array size matches size(itr).\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum-Tuple{Array{<:Object2d}}","page":"Methods","title":"ImagePhantoms.spectrum","text":"spectrum(oa::Array{<:Object2d})::Function\n\nReturn function kspace(fx,fy) that user can sample at any spatial frequency locations to evaluate the spectrum (2D Fourier transform) for an Array of 2D objects.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum-Tuple{Array{<:Object3d}}","page":"Methods","title":"ImagePhantoms.spectrum","text":"spectrum(oa::Array{<:Object3d})::Function\n\nReturn function kspace(fx,fy,fz) that user can sample at any spatial frequency locations to evaluate the spectrum (3D Fourier transform) for an Array of 3D objects.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum-Tuple{Object2d, AbstractVector, Any}","page":"Methods","title":"ImagePhantoms.spectrum","text":"spectrum(ob::Object2d, coefs::AbstractVector, f::)\n\nVersion of spectrum(ob) suitable for parallel MRI with sensitivity maps that were fit previously using mri_smap_fit for a single coil with fit coefficients coefs and frequencies f (array of tuples).\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum-Tuple{Object2d, NamedTuple, Int64}","page":"Methods","title":"ImagePhantoms.spectrum","text":"spectrum(ob::Object2d, fit::NamedTuple, coil::Int)\n\nVersion of spectrum(ob) suitable for parallel MRI with sensitivity maps that were fit previously using mri_smap_fit.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum-Tuple{Object2d}","page":"Methods","title":"ImagePhantoms.spectrum","text":"spectrum(ob::Object2d)::Function\n\nReturn function of (fx,fy) that user can sample at any spatial frequency locations to evaluate the spectrum (2D Fourier transform) of a single 2D object. Units of spatial frequencies should be the reciprocal of the units defining the object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum-Tuple{Object3d}","page":"Methods","title":"ImagePhantoms.spectrum","text":"spectrum(ob::Object3d)::Function\n\nReturn function of (fx,fy,fz) that user can sample at any spatial frequency locations to evaluate the spectrum (3D Fourier transform) of a single 3D object. Units of spatial frequencies should be the reciprocal of the units defining the object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum1-Tuple{Object2d{Dirac2}, Tuple{Real, Real}}","page":"Methods","title":"ImagePhantoms.spectrum1","text":"spectrum1(::Object2d{Dirac2}, (kx,ky))\n\nSpectrum of Dirac2 at (kx,ky), for unitless spatial frequency coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum1-Tuple{Object2d{Ellipse}, Tuple{Real, Real}}","page":"Methods","title":"ImagePhantoms.spectrum1","text":"spectrum1(::Object2d{Ellipse}, (kx,ky))\n\nSpectrum of unit circle at (kx,ky), for unitless spatial frequency coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum1-Tuple{Object2d{Gauss2}, Tuple{Real, Real}}","page":"Methods","title":"ImagePhantoms.spectrum1","text":"spectrum1(::Object2d{Gauss2}, (kx,ky))\n\nSpectrum of unit gauss2 at (kx,ky), for unitless spatial frequency coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum1-Tuple{Object2d{Rect}, Tuple{Real, Real}}","page":"Methods","title":"ImagePhantoms.spectrum1","text":"spectrum1(::Object2d{Rect}, (kx,ky))\n\nSpectrum of unit square at (kx,ky), for unitless spatial frequency coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum1-Tuple{Object2d{Triangle}, Tuple{Real, Real}}","page":"Methods","title":"ImagePhantoms.spectrum1","text":"spectrum1(ob::Object2d{Triangle}, (kx,ky))\n\nSpectrum of unit triangle at (kx,ky), for unitless spatial frequency coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum1-Tuple{Object3d{Cuboid}, Tuple{Real, Real, Real}}","page":"Methods","title":"ImagePhantoms.spectrum1","text":"spectrum1(::Object3d{Cuboid}, (kx,ky,kz))\n\nSpectrum of unit cube at (kx,ky,kz), for unitless spatial frequency coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum1-Tuple{Object3d{Cylinder}, Tuple{Real, Real, Real}}","page":"Methods","title":"ImagePhantoms.spectrum1","text":"spectrum(::Object3d{Cylinder}, (kx,ky,kz))\n\nSpectrum of unit cylinder at (kx,ky,kz), for unitless spatial frequency coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum1-Tuple{Object3d{Dirac3}, Tuple{Real, Real, Real}}","page":"Methods","title":"ImagePhantoms.spectrum1","text":"spectrum1(::Object3d{Dirac3}, (kx,ky,kz))\n\nSpectrum of Dirac3 at (kx,ky,kz), for unitless spatial frequency coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum1-Tuple{Object3d{Ellipsoid}, Tuple{Real, Real, Real}}","page":"Methods","title":"ImagePhantoms.spectrum1","text":"spectrum1(::Object3d{Ellipsoid}, (kx,ky,kz))\n\nSpectrum of unit sphere at (kx,ky,kz), for unitless spatial frequency coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.spectrum1-Tuple{Object3d{Gauss3}, Tuple{Real, Real, Real}}","page":"Methods","title":"ImagePhantoms.spectrum1","text":"spectrum1(::Object3d{Gauss3}, (kx,ky,kz))\n\nSpectrum of unit sphere at (kx,ky,kz), for unitless spatial frequency coordinates.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.sphere","page":"Methods","title":"ImagePhantoms.sphere","text":"sphere(x, y, z, r,v=1) (sphere of radius `r` centered at `(x,y,z)`)\nsphere((x,y,z), r, v=1) ditto\nsphere(r, v=1) centered at origin\n\nConstruct spheres as special cases of Ellipsoid.\n\n\n\n\n\n","category":"function"},{"location":"methods/#ImagePhantoms.sphere_transform-Tuple{T} where T<:AbstractFloat","page":"Methods","title":"ImagePhantoms.sphere_transform","text":"sphere_transform(f::Real)\n\nFourier transform of unit-radius sphere. The argument f is the radial coordinate in k-space and is unitless. See p253 of Bracewell 1978, The Fourier transform and its applications, or https://doi.org/10.1002/mrm.21292.\n\nFormula: 4/3 π for f ≈ 0, otherwise (sin(2πf) - 2πf cos(2πf)) / (2 * π^2 * f^3).\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.square","page":"Methods","title":"ImagePhantoms.square","text":"square(x, y, w,v=1) (square of width `w` centered at `(x,y)`)\nsquare((x,y), w=1, v=1) ditto\nsquare(w, v=1) centered at origin\n\nConstruct squares as special cases of Rect.\n\n\n\n\n\n","category":"function"},{"location":"methods/#ImagePhantoms.translate-Union{Tuple{D}, Tuple{S}, Tuple{Object{S, D}, NTuple{D, Number}}} where {S, D}","page":"Methods","title":"ImagePhantoms.translate","text":"translate(ob::Object, shift::NTuple{D,RealU})\ntranslate(ob::Object{S,2}, xshift, yshift)\ntranslate(ob::Object{S,3}, xshift, yshift, zshift)\n\nTranslate the center coordinates of an object by shift\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.trapezoid-NTuple{5, Real}","page":"Methods","title":"ImagePhantoms.trapezoid","text":"trapezoid(t::Real, t1, t2, t3, t4)\n\nUnit-height trapezoid with breakpoints t1, t2, t3, t4.\n\n\n\n\n\n","category":"method"},{"location":"methods/#ImagePhantoms.triangle-Tuple","page":"Methods","title":"ImagePhantoms.triangle","text":"triangle(cx, cy, wx=1, wy=wx, ϕ=0, value::Number=1, param::Real=0.5)\ntriangle(center::NTuple{2,RealU}, width::NTuple{2,RealU}=(1,1), ϕ::RealU=0, v=1, param=0.5)\n\nConstruct Object{Triangle} from parameters. In the typical case where param=0.5 and width[1] == width[2], this is an equilateral triangle with base width[1] centered along the x axis.\n\n\n\n\n\n","category":"method"},{"location":"generated/examples/01-overview/#01-overview","page":"ImagePhantoms overview","title":"ImagePhantoms overview","text":"This page explains the Julia package ImagePhantoms.\n\nThis page comes from a single Julia file: 01-overview.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 01-overview.ipynb, or open it in binder here: 01-overview.ipynb.","category":"section"},{"location":"generated/examples/01-overview/#Setup","page":"ImagePhantoms overview","title":"Setup","text":"Packages needed here.\n\nusing ImagePhantoms\nusing ImageGeoms: ImageGeom, axesf\nusing MIRTjim: jim, prompt, mid3\nusing Plots; default(markerstrokecolor=:auto, label=\"\")\nusing Unitful: mm\nusing InteractiveUtils: versioninfo\n\nThe following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/01-overview/#Overview","page":"ImagePhantoms overview","title":"Overview","text":"When developing image reconstruction methods, it can be helpful to simulate data (e.g., sinograms) using software-defined images called phantoms.\n\nThe simplest method here is to make a Shepp-Logan phantom image similar its use in other packages.\n\nimage = shepp_logan(256) # CT version by default\njim(image, \"SheppLogan\"; clim=(0.9, 1.1))","category":"section"},{"location":"generated/examples/01-overview/#Sinograms","page":"ImagePhantoms overview","title":"Sinograms","text":"Often for image reconstruction algorithm development, we need not only the phantom image, but also its sinogram, i.e., Radon transform and spectrum.\n\nThe 2D sinogram coordinate system used here is\n\np(r ϕ) = int_-^ f(r cos ϕ - ℓ sin ϕ r sin ϕ + ℓ cos ϕ)  mathrmd ℓ\n\nWe start with the vector of ellipses that defines the phantom, using a typical field of view (FOV) of 200mm for a head:\n\nobjects = shepp_logan(SheppLoganToft(); fovs=(200mm,200mm))\n\nFrom that collection we can compute images, sinograms and spectra. Use phantom to make digital images. It is convenient (but not required) to use ImageGeoms to help with the sampling.\n\nig = ImageGeom(dims=(200,256), deltas=(1mm,1mm))\nimage = phantom(axes(ig)..., objects)\njim(axes(ig), image; xlabel=\"x\", ylabel=\"y\", title=\"SheppLoganToft\")\n\nHere is the sinogram corresponding to this phantom, computed analytically from the ellipse parameters using radon:\n\nr = range(-100mm,100mm,401)\nϕ = deg2rad.(0:180)\nsino = radon(r, ϕ, objects)\njim(r, ϕ, sino; title=\"Sinogram\", xlabel=\"r\", ylabel=\"ϕ\")","category":"section"},{"location":"generated/examples/01-overview/#Spectra","page":"ImagePhantoms overview","title":"Spectra","text":"Here is the 2D spectrum (Fourier transform) of this phantom, computed analytically from the ellipse parameters using spectrum:\n\nkspace = spectrum(axesf(ig)..., objects)\njim(axesf(ig), log10.(abs.(kspace/(1mm)^2)); xlabel=\"ν₁\", ylabel=\"ν₂\", title=\"log10|Spectrum|\")\n\nThe 2D Fourier transform formula used here is:\n\nF(ν_1 ν_2) =   f(xy)  mathrme^-ı 2π (ν_1 x + ν_2 y)  mathrmd x  mathrmd y\n\nso if x and y have units mm (for example), then the units of the spatial frequency variables ν_1 and ν_2 are cycles/mm.","category":"section"},{"location":"generated/examples/01-overview/#2D-Rotation","page":"ImagePhantoms overview","title":"2D Rotation","text":"All of the 2D objects (ellipses etc.) in this package can be rotated by an angle ϕ.\n\nThis package treats the rotation angle ϕ as defining a rotation of the object. Be aware that a rotation of the axes has the opposite sign convention.\n\nAfter rotation by ϕ, any point (xy) in the original ellipse becomes the point\n\nleft beginmatrix\nx  y\nendmatrix right\n=\nleft beginmatrix\ncos(ϕ)  -sin(ϕ)  sin(ϕ)  cos(ϕ)\nendmatrix right\nleft beginmatrix\nx  y\nendmatrix right\n\nas illustrated by the blue star below when rotating an ellipse by ϕ = π6.\n\nellipse0 = ellipse(0, 0, 8, 4, 0, 1)\nϕ1s = :(π/6)\nϕ1 = eval(ϕ1s)\nellipse1 = ellipse(0, 0, 8, 4, ϕ1, 1)\n\nx = range(-9, 9, 181)\ny = range(-8, 8, 161)\npic0 = phantom(x, y, [ellipse0])\npic1 = phantom(x, y, [ellipse1])\n\nmarker = :star\np0 = jim(x, y, pic0, \"Original ellipse\";\n    xlabel=\"x\", ylabel=\"y\", size=(700,300), prompt=:false)\nx0,y0 = 7,0\nscatter!([x0], [y0], color=:blue; marker)\npoint1 = [cos(ϕ1) -sin(ϕ1); sin(ϕ1) cos(ϕ1)] * [x0; y0] # rotate point\nx1,y1 = point1[1], point1[2]\np1 = jim(x, y, pic1, \"Rotated by ϕ = $ϕ1s\";\n    xlabel=\"x\", ylabel=\"y\", size=(700,300), prompt=:false)\nscatter!([x1], [y1], color=:blue; marker)\njim(p0, p1)","category":"section"},{"location":"generated/examples/01-overview/#3D-Rotation","page":"ImagePhantoms overview","title":"3D Rotation","text":"For a 3D object, there are three rotation angles, often called Euler angles, and there are many possible conventions for the names and ordering of these angles.\n\nThis package denotes the three angles as ϕθψ","category":"section"},{"location":"generated/examples/01-overview/#Rotation-about-z-by-ϕ","page":"ImagePhantoms overview","title":"Rotation about z by ϕ","text":"For consistency with the 2D case, the first of the three angles, ϕ, denotes rotation in the (xy) plane, i.e., around the z-axis. In wikipedia's notation this is R_z(ϕ), defined as\n\nleft beginmatrix\nx  y  z\nendmatrix right\n=\nleft beginmatrix\ncos(θ)  -sin(θ)  0\n\nsin(θ)  cos(θ)  0\n\n0  0  1\n\nendmatrix right\nleft beginmatrix\nx  y  z\nendmatrix right\n\nas illustrated by the blue star below.\n\nHere is an illustration for ϕ = π6.\n\nellipsoid0 = ellipsoid((0, 0, 0), (8, 4, 2), (0, 0, 0), 1)\nϕ1s = :(π/6)\nϕ1 = eval(ϕ1s)\nellipsoid1 = ellipsoid((0, 0, 0), (8, 4, 2), (ϕ1, 0, 0), 1)\n\nx = range(-9, 9, 181)\ny = range(-8, 8, 161)\nz = [0]\npic0 = phantom(x, y, z, [ellipsoid0])\npic1 = phantom(x, y, z, [ellipsoid1])\n\np0z = jim(x, y, pic0,\n    \"Original ellipsoid:\\n(x,y) slice\";\n    xlabel=\"x\", ylabel=\"y\", size=(700,300), prompt=:false)\nx0,y0 = 7,0\nscatter!([x0], [y0], color=:blue; marker)\nRz(ϕ) = [cos(ϕ) -sin(ϕ) 0; sin(ϕ) cos(ϕ) 0; 0 0 1]\npoint1 = Rz(ϕ1) * [x0; y0; 0] # rotate point\nx1,y1 = point1[1], point1[2]\np1z = jim(x, y, pic1,\n    \"Rotated about z\\nby ϕ = $ϕ1s\\n(z out of 'board')\";\n    xlabel=\"x\", ylabel=\"y\", size=(700,350), prompt=:false)\nscatter!([x1], [y1], color=:blue; marker)\njim(p0z, p1z)","category":"section"},{"location":"generated/examples/01-overview/#Rotation-about-y-by-θ","page":"ImagePhantoms overview","title":"Rotation about y by θ","text":"The 2nd of the three angles, θ, corresponds to rotation around the y-axis, which has the opposite sign when using the right hand rule:\n\nleft beginmatrix\nx  y  z\nendmatrix right\n=\nleft beginmatrix\ncos(θ)  0  sin(θ)\n\n0  1  0\n\n-sin(θ)  0  cos(θ)\n\nendmatrix right\nleft beginmatrix\nx  y  z\nendmatrix right\n\nas illustrated by the green star below.\n\nIn wikipedia notation this is R_y(θ).\n\nHere is an illustration of rotating an ellipsoid for θ = π6.\n\nellipsoid0 = ellipsoid((0, 0, 0), (8, 4, 2), (0, 0, 0), 1)\nθ1s = :(π/6)\nθ1 = eval(θ1s)\nellipsoid1 = ellipsoid((0, 0, 0), (8, 4, 2), (0, θ1, 0), 1)\n\nx = range(-9, 9, 181)\ny = [0]\nz = range(-8, 8, 161)\npic0 = phantom(x, y, z, [ellipsoid0]); pic0 = selectdim(pic0, 2, 1)\npic1 = phantom(x, y, z, [ellipsoid1]); pic1 = selectdim(pic1, 2, 1)\n\np0y = jim(x, z, pic0,\n    \"Original ellipsoid:\\n (x,z) slice\";\n    xlabel=\"x\", ylabel=\"z\", size=(700,350), prompt=false)\nx0,z0 = 7,0\nscatter!([x0], [z0], color=:green; marker)\nRy(θ) = [cos(θ) 0 sin(θ); 0 1 0; -sin(θ) 0 cos(θ)]\npoint1 = Ry(θ1) * [x0; 0; z0] # rotate point\nx1,z1 = point1[1], point1[3]\np1y = jim(x, z, pic1,\n    \"Rotated about y\\nby θ = $θ1s\\n(y into 'board')\";\n    xlabel=\"x\", ylabel=\"z\", size=(700,350), prompt=false)\nscatter!([x1], [z1], color=:green; marker)\njim(p0y, p1y)","category":"section"},{"location":"generated/examples/01-overview/#Rotation-about-x-by-ψ","page":"ImagePhantoms overview","title":"Rotation about x by ψ","text":"The 3rd of the three angles, ψ, corresponds to rotation around the x-axis:\n\nleft beginmatrix\nx  y  z\nendmatrix right\n=\nleft beginmatrix\n1  0  0\n\n0  cos(ψ)  -sin(ψ)\n\n0  sin(ψ)  cos(ψ)\n\nendmatrix right\nleft beginmatrix\nx  y  z\nendmatrix right\n\nas illustrated by the red star below.\n\nIn wikipedia notation this is R_x(ψ).\n\nHere is an illustration of rotating an ellipsoid for ψ = π6.\n\nellipsoid0 = ellipsoid((0, 0, 0), (8, 4, 2), (0, 0, 0), 1)\nψ1s = :(π/6)\nψ1 = eval(ψ1s)\nellipsoid1 = ellipsoid((0, 0, 0), (8, 4, 2), (0, 0, ψ1), 1)\n\nx = [0]\ny = range(-9, 9, 181)\nz = range(-8, 8, 161)\npic0 = phantom(x, y, z, [ellipsoid0]); pic0 = selectdim(pic0, 1, 1)\npic1 = phantom(x, y, z, [ellipsoid1]); pic1 = selectdim(pic1, 1, 1)\n\np0x = jim(y, z, pic0,\n    \"Original ellipsoid:\\n (y,z) slice)\";\n    xlabel=\"y\", ylabel=\"z\", size=(700,350), prompt=false)\ny0,z0 = 3,0\nscatter!([y0], [z0], color=:red; marker)\nRx(ψ) = [1 0 0 ; 0 cos(ψ) -sin(ψ); 0 sin(ψ) cos(ψ)]\npoint1 = Rx(ψ1) * [0; y0; z0] # rotate point\ny1,z1 = point1[2], point1[3]\np1x = jim(y, z, pic1,\n    \"Rotated about x\\nby ψ = $ψ1s\\n(x out of 'board')\";\n    xlabel=\"y\", ylabel=\"z\", size=(700,350), prompt=false)\nscatter!([y1], [z1], color=:red; marker)\njim(p0x, p1x)\n\nThe remaining issue is the multiplication order for multiple rotations.\n\nTo address that, we first describe how phantoms are generated in this package. Every phantom shape starts with a base function that is translated, rotated, and scaled to make the final object. For example, an ellipsoid is a transformed sphere. Specifically, if e(r) is the ellipsoid function, and s(r) is the unit sphere function, where r = (xyz), then\n\ne(r) = s( (R_xyz^T (r - c))  w )\n\nwhere c is the center of the ellipsoid, and r is the width parameter (actually radii),  denotes element-wise division, and R_xyz^T is the inverse of the 3D rotation matrix R_xyz defined by R_xyz = R_x(ψ) R_y(θ) R_z(ϕ).\n\nNote that r and c and w all must have identical units, so the argument (R_xyz^T (r - c))  w passed the unit-sphere function is unitless, as it must be. The non-exported phantom1 function for each shape defines the base shape function. For the unit sphere it is simply sum(abs2, r) ≤ 1.\n\nRearranging the equation r = (R_xyz^T (r - c))  w yields r = R_xyz (w  r) + c. So the process of transforming a unit sphere to an ellipsoid starts with scaling, then rotation by R_xyz, which rotates first around the z-axis, and then finally translating.\n\nHere is an illustration where one can see that all three axes were rotated.\n\nellipsoid0 = ellipsoid((0, 0, 0), (8, 4, 2), (0, 0, 0), 1)\nϕ1s = :(π/6)\nϕ1 = eval(ϕ1s)\nθ1s = :(π/7)\nθ1 = eval(θ1s)\nψ1s = :(π/8)\nψ1 = eval(ψ1s)\nellipsoid1 = ellipsoid((0, 0, 0), (8, 4, 2), (ϕ1, θ1, ψ1), 1)\n\nx = range(-9, 9, 181)\ny = range(-8, 8, 161)\nz = range(-7, 7, 71)\npic0 = phantom(x, y, z, [ellipsoid0])\npic1 = phantom(x, y, z, [ellipsoid1])\n\np0a = jim(mid3(pic0),\n    \"Original ellipsoid\\n(central slices)\";\n    xlabel=\"x\", ylabel=\"y\", size=(700,320), prompt=:false)\np1a = jim(mid3(pic1),\n    \"Rotated\\nϕ = $ϕ1s, θ = $θ1s, ψ = $ψ1s\";\n    xlabel=\"x\", ylabel=\"y\", size=(700,320), prompt=:false)\njim(p0a, p1a)","category":"section"},{"location":"generated/examples/01-overview/#Spectra-rotation","page":"ImagePhantoms overview","title":"Spectra rotation","text":"The spectrum method accounts for the translation, rotation, and scaling of the base shape function using elementary Fourier transform properties.\n\nThe following code first shows the spectra of an ellipsoid before and after rotating it.\n\nig = ImageGeom(length.((x,y,z)), map(x -> x[2]-x[1], (x,y,z)))\nkspace0 = spectrum(axesf(ig)..., [ellipsoid0])\nkspace1 = spectrum(axesf(ig)..., [ellipsoid1])\n@assert ImagePhantoms.volume(ellipsoid0) == ImagePhantoms.volume(ellipsoid1)\n\nclim = (-6, 0)\np0s = jim(axesf(ig), log10.(abs.(kspace0 / ImagePhantoms.volume(ellipsoid0)));\n    clim, xlabel=\"ν₁\", ylabel=\"ν₂\", title=\"log10|Spectrum original ellipsoid|\")\n\np1s = jim(axesf(ig), log10.(abs.(kspace1 / ImagePhantoms.volume(ellipsoid1)));\n    clim, xlabel=\"ν₁\", ylabel=\"ν₂\", title=\"log10|Spectrum rotated ellipsoid|\")\n\nThe following code verifies that the rotated spectrum matches\n\nk = Iterators.product(axesf(ig)...) # tuples of (kx,ky,kz) values\nR = Rx(ψ1) * Ry(θ1) * Rz(ϕ1) # Rxyz rotation matrix\nkr = (tuple((R' * collect(k))...) for k in k) # rotate each k-space tuple\nkspace0r = spectrum(kr, [ellipsoid0]) # evaluate spectrum at rotated tuples\n@assert kspace0r ≈ kspace1","category":"section"},{"location":"generated/examples/01-overview/#Reproducibility","page":"ImagePhantoms overview","title":"Reproducibility","text":"This page was generated with the following version of Julia:\n\nusing InteractiveUtils: versioninfo\nio = IOBuffer(); versioninfo(io); split(String(take!(io)), '\\n')\n\nAnd with the following package versions\n\nimport Pkg; Pkg.status()\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/02-ellipse/#02-ellipse","page":"Ellipse","title":"Ellipse","text":"This page illustrates the Ellipse shape in the Julia package ImagePhantoms.\n\nThis page comes from a single Julia file: 02-ellipse.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 02-ellipse.ipynb, or open it in binder here: 02-ellipse.ipynb.","category":"section"},{"location":"generated/examples/02-ellipse/#Setup","page":"Ellipse","title":"Setup","text":"Packages needed here.\n\nusing ImagePhantoms: ellipse\nusing ImagePhantoms: phantom, radon, spectrum\nimport ImagePhantoms as IP\nusing ImageGeoms: ImageGeom, axesf\nusing MIRTjim: jim, prompt\nusing FFTW: fft, fftshift, ifftshift\nusing Unitful: mm, unit, °\nusing Plots: plot, plot!, scatter!, default\ndefault(markerstrokecolor=:auto)\n\nThe following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/02-ellipse/#Overview","page":"Ellipse","title":"Overview","text":"A useful shape for constructing 2D digital image phantoms is the ellipse, specified by its center, radii, angle and value. All of the methods in ImagePhantoms support physical units, so we use such units throughout this example. (Using units is recommended but not required.)\n\nDefine an ellipse object, using physical units.\n\nradii = (20mm, 80mm)\nob = ellipse((40mm, 30mm), radii, π/6, 1.0f0)","category":"section"},{"location":"generated/examples/02-ellipse/#Phantom-image-using-phantom","page":"Ellipse","title":"Phantom image using phantom","text":"Make a digital image of it using phantom and display it.\n\ndx, dy = 0.8mm, 1.0mm\nM, N = (2^8, 2^8+2)\nx = (-M÷2:M÷2-1) * dx\ny = (-N÷2:N÷2-1) * dy\noversample = 2\nimg = phantom(x, y, [ob], oversample)\njim(x, y, img, \"Ellipse image\")\n\nHereafter we use ImageGeoms to simplify the indexing.\n\nM, N = (2^8, 2^8+17) # odd\nig = ImageGeom(dims=(M,N), deltas=(dx,dy), offsets=:dsp)\n@assert axes(ig)[1] ≈ x\noversample = 2\nimg = phantom(axes(ig)..., [ob], oversample)\np1 = jim(axes(ig), img, \"Ellipse phantom\", xlabel=\"x\", ylabel=\"y\")\n\nThe image integral should approximate the object area\n\narea = IP.area(ob)\n(sum(img) * prod(ig.deltas), area)","category":"section"},{"location":"generated/examples/02-ellipse/#Spectrum-using-spectrum","page":"Ellipse","title":"Spectrum using spectrum","text":"There are two ways to examine the spectrum of this image:\n\nusing the analytical Fourier transform of the object via spectrum\napplying the DFT via FFT to the digital image.\n\nBecause the shape has units mm, the spectra axes have units cycles/mm.\n\nvscale = 1 / area # normalize spectra by area\nspectrum_exact = spectrum(axesf(ig)..., [ob]) * vscale\nsp = z -> max(log10(abs(z)/oneunit(abs(z))), -6) # log-scale for display\nclim = (-6, 0) # colorbar limit for display\n(xlabel, ylabel) = (\"ν₁\", \"ν₂\")\np2 = jim(axesf(ig), sp.(spectrum_exact), \"log10|Spectrum|\"; clim, xlabel, ylabel)\n\nSadly fft cannot handle units currently, so this function is a work-around:\n\nfunction myfft(x)\n    u = unit(eltype(x))\n    return fftshift(fft(ifftshift(x) / u)) * u\nend\n\nspectrum_fft = myfft(img) * (prod(ig.deltas) * vscale)\np3 = jim(axesf(ig), sp.(spectrum_fft), \"log10|DFT|\"; clim, xlabel, ylabel)\n\nCompare the DFT and analytical spectra to validate the code\n\nerrf = maximum(abs, spectrum_exact - spectrum_fft) / maximum(abs, spectrum_exact)\n@assert errf < 2e-3\np4 = jim(axesf(ig), 1e3*abs.(spectrum_fft - spectrum_exact),\n    \"|Difference| × 10³\"; xlabel, ylabel)\njim(p1, p4, p2, p3)","category":"section"},{"location":"generated/examples/02-ellipse/#Radon-transform-using-radon","page":"Ellipse","title":"Radon transform using radon","text":"Examine the Radon transform of the object using radon, and validate it using the projection-slice theorem aka Fourier-slice theorem.\n\ndr = 0.2mm # radial sample spacing\nnr = 2^10 # radial sinogram bins\nr = (-nr÷2:nr÷2-1) * dr # radial samples\nfr = (-nr÷2:nr÷2-1) / nr / dr # corresponding spectral axis\nϕ = deg2rad.(0:180)\nsino = radon(ob).(r, ϕ') # sample Radon transform of a single shape object\nsmax = ob.value * 2 * maximum(radii)\np5 = jim(r, rad2deg.(ϕ), sino; title=\"sinogram\",\n    xlabel=\"r\", ylabel=\"ϕ\", clim = (0,1) .* smax)\n\nThe maximum sinogram value is about 160mm, which makes sense for an ellipse whose long axis has \"radius\" 80mm.\n\nThe above sampling generated a parallel-beam sinogram, but one could make a fan-beam sinogram by sampling (r, ϕ) appropriately.","category":"section"},{"location":"generated/examples/02-ellipse/#Fourier-slice-theorem-illustration","page":"Ellipse","title":"Fourier-slice theorem illustration","text":"Pick one particular view angle (55°) and look at its slice and spectra.\n\nia = argmin(abs.(ϕ .- 55°))\nslice = sino[:,ia]\nslice_fft = myfft(slice) * dr\nϕd = round(rad2deg(ϕ[ia]), digits=1)\n\nkx, ky = (fr * cos(ϕ[ia]), fr * sin(ϕ[ia])) # Fourier-slice theorem\nslice_ft = spectrum(ob).(kx, ky)\nerrs = maximum(abs, slice_ft - slice_fft) / maximum(abs, slice_ft)\n@assert errs < 2e-4\n\np3 = plot(r, slice, title=\"profile at ϕ = $ϕd\", label=\"\")\np4 = plot(title=\"1D spectra\")\nscatter!(fr, abs.(slice_fft), label=\"abs fft\", color=:blue)\nscatter!(fr, real(slice_fft), label=\"real fft\", color=:green)\nscatter!(fr, imag(slice_fft), label=\"imag fft\", color=:red,\n    xlims=(-1,1) .* (0.1/mm))\n\nplot!(fr, abs.(slice_ft), label=\"abs\", color=:blue)\nplot!(fr, real(slice_ft), label=\"real\", color=:green)\nplot!(fr, imag(slice_ft), label=\"imag\", color=:red)\nplot(p1, p5, p3, p4)\n\nThe good agreement between the analytical spectra (solid lines) and the DFT samples (disks) validates that phantom, radon, and spectrum are all self consistent for this shape.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/09-disk/#09-disk","page":"Random Disks","title":"Random Disks","text":"This page illustrates the disk_phantom_params method in the Julia package ImagePhantoms.\n\nThis page comes from a single Julia file: 09-disk.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 09-disk.ipynb, or open it in binder here: 09-disk.ipynb.","category":"section"},{"location":"generated/examples/09-disk/#Setup","page":"Random Disks","title":"Setup","text":"Packages needed here.\n\nusing ImagePhantoms: ellipse, phantom, disk_phantom_params\nusing ImageGeoms: ImageGeom\nusing MIRTjim: jim, prompt\nusing Plots # @animate, gif\nusing Random: seed!\n\nThe following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/09-disk/#Overview","page":"Random Disks","title":"Overview","text":"For training machine-learning methods for image reconstruction, it can be helpful to have a way to generate a family of phantoms drawn from some common distribution, especially for debugging or when real ground-truth data is limited. The disk_phantom_params function is one example of how one can use the tools in this package to generate such phantoms.","category":"section"},{"location":"generated/examples/09-disk/#A-single-disk-phantom-image","page":"Random Disks","title":"A single disk phantom image","text":"Make a digital image of it using phantom and display it.\n\nfunction disk_phantom(title::String)\n    (dx,dy) = (1, 1)\n    (M,N) = (2^8,2^8)\n    x = (-M÷2:M÷2-1) * dx\n    y = (-N÷2:N÷2-1) * dy\n    params = disk_phantom_params( ; rhead = () -> rand(100:105))\n    objects = ellipse(params) # vector of Object{Ellipse}\n    oversample = 3\n    img = phantom(x, y, objects, oversample)\n    jim(x, y, img; title, clim=(0,1300))\nend\nseed!(0)\ndisk_phantom(\"A single disk phantom realization\")","category":"section"},{"location":"generated/examples/09-disk/#Several-realizations","page":"Random Disks","title":"Several realizations","text":"anim = @animate for i in 1:8\n    disk_phantom(\"Realization $i\")\nend\ngif(anim, \"disk.gif\", fps = 6)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/03-rect/#03-rect","page":"Rectangle","title":"Rectangle","text":"This page illustrates the Rect shape in the Julia package ImagePhantoms.\n\nThis page comes from a single Julia file: 03-rect.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 03-rect.ipynb, or open it in binder here: 03-rect.ipynb.","category":"section"},{"location":"generated/examples/03-rect/#Setup","page":"Rectangle","title":"Setup","text":"Packages needed here.\n\nusing ImagePhantoms: rect\nusing ImagePhantoms: phantom, radon, spectrum\nimport ImagePhantoms as IP\nusing ImageGeoms: ImageGeom, axesf\nusing MIRTjim: jim, prompt\nusing FFTW: fft, fftshift, ifftshift\nusing Unitful: mm, unit, °\nusing Plots: plot, plot!, scatter!, default\ndefault(markerstrokecolor=:auto)\n\nThe following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/03-rect/#Overview","page":"Rectangle","title":"Overview","text":"A useful shape for constructing 2D digital image phantoms is the rectangle, specified by its center, widths, angle and value. All of the methods in ImagePhantoms support physical units, so we use such units throughout this example. (Using units is recommended but not required.)\n\nDefine a rectangle object, using physical units.\n\nwidth = (20mm, 80mm)\nob = rect((40mm, 30mm), width, π/6, 1.0f0)","category":"section"},{"location":"generated/examples/03-rect/#Phantom-image-using-phantom","page":"Rectangle","title":"Phantom image using phantom","text":"Make a digital image of it using phantom and display it.\n\ndx, dy = 0.8mm, 1.0mm\nM, N = (2^8, 2^8+2)\nx = (-M÷2:M÷2-1) * dx\ny = (-N÷2:N÷2-1) * dy\noversample = 2\nimg = phantom(x, y, [ob], oversample)\njim(x, y, img, \"Rect image\")\n\nHereafter we use ImageGeoms to simplify the indexing.\n\nM, N = (2^8, 2^8+17) # odd\nig = ImageGeom(dims=(M,N), deltas=(dx,dy), offsets=:dsp)\n@assert axes(ig)[1] ≈ x\noversample = 2\nimg = phantom(axes(ig)..., [ob], oversample)\np1 = jim(axes(ig), img, \"Rect phantom\", xlabel=\"x\", ylabel=\"y\")\n\nThe image integral should approximate the object area\n\narea = IP.area(ob)\n(sum(img) * prod(ig.deltas), area)","category":"section"},{"location":"generated/examples/03-rect/#Spectrum-using-spectrum","page":"Rectangle","title":"Spectrum using spectrum","text":"There are two ways to examine the spectrum of this image:\n\nusing the analytical Fourier transform of the object via spectrum\napplying the DFT via FFT to the digital image.\n\nBecause the shape has units mm, the spectra axes have units cycles/mm.\n\nvscale = 1 / area # normalize spectra by area\nspectrum_exact = spectrum(axesf(ig)..., [ob]) * vscale\nsp = z -> max(log10(abs(z)/oneunit(abs(z))), -6) # log-scale for display\nclim = (-6, 0) # colorbar limit for display\n(xlabel, ylabel) = (\"ν₁\", \"ν₂\")\np2 = jim(axesf(ig), sp.(spectrum_exact), \"log10|Spectrum|\"; clim, xlabel, ylabel)\n\nSadly fft cannot handle units currently, so this function is a work-around:\n\nfunction myfft(x)\n    u = unit(eltype(x))\n    return fftshift(fft(ifftshift(x) / u)) * u\nend\n\nspectrum_fft = myfft(img) * (prod(ig.deltas) * vscale)\np3 = jim(axesf(ig), sp.(spectrum_fft), \"log10|DFT|\"; clim, xlabel, ylabel)\n\nCompare the DFT and analytical spectra to validate the code\n\nerrf = maximum(abs, spectrum_exact - spectrum_fft) / maximum(abs, spectrum_exact)\n@assert errf < 2e-2\np4 = jim(axesf(ig), 1e3*abs.(spectrum_fft - spectrum_exact),\n    \"|Difference| × 10³\"; xlabel, ylabel)\njim(p1, p4, p2, p3)","category":"section"},{"location":"generated/examples/03-rect/#Radon-transform-using-radon","page":"Rectangle","title":"Radon transform using radon","text":"Examine the Radon transform of the object using radon, and validate it using the projection-slice theorem aka Fourier-slice theorem.\n\ndr = 0.2mm # radial sample spacing\nnr = 2^10 # radial sinogram bins\nr = (-nr÷2:nr÷2-1) * dr # radial samples\nfr = (-nr÷2:nr÷2-1) / nr / dr # corresponding spectral axis\nϕ = deg2rad.(0:180)\nsino = radon(ob).(r, ϕ') # sample Radon transform of a single shape object\nsmax = ob.value * sqrt(sum(abs2, maximum(width)))\np5 = jim(r, rad2deg.(ϕ), sino; title=\"sinogram\",\n    xlabel=\"r\", ylabel=\"ϕ\", clim = (0,1) .* smax)\n\nThe maximum sinogram value is about sqrt(80^2+20^2) = 82.mm, which makes sense for a 80mm × 20mm rect.\n\nThe above sampling generated a parallel-beam sinogram, but one could make a fan-beam sinogram by sampling (r, ϕ) appropriately.","category":"section"},{"location":"generated/examples/03-rect/#Fourier-slice-theorem-illustration","page":"Rectangle","title":"Fourier-slice theorem illustration","text":"Pick one particular view angle (55°) and look at its slice and spectra.\n\nia = argmin(abs.(ϕ .- 55°))\nslice = sino[:,ia]\nslice_fft = myfft(slice) * dr\nϕd = round(rad2deg(ϕ[ia]), digits=1)\n\nkx, ky = (fr * cos(ϕ[ia]), fr * sin(ϕ[ia])) # Fourier-slice theorem\nslice_ft = spectrum(ob).(kx, ky)\nerrs = maximum(abs, slice_ft - slice_fft) / maximum(abs, slice_ft)\n@assert errs < 3e-5\n\np3 = plot(r, slice, title=\"profile at ϕ = $ϕd\", label=\"\")\np4 = plot(title=\"1D spectra\")\nscatter!(fr, abs.(slice_fft), label=\"abs fft\", color=:blue)\nscatter!(fr, real(slice_fft), label=\"real fft\", color=:green)\nscatter!(fr, imag(slice_fft), label=\"imag fft\", color=:red,\n    xlims=(-1,1) .* (0.1/mm))\n\nplot!(fr, abs.(slice_ft), label=\"abs\", color=:blue)\nplot!(fr, real(slice_ft), label=\"real\", color=:green)\nplot!(fr, imag(slice_ft), label=\"imag\", color=:red)\nplot(p1, p5, p3, p4)\n\nThe good agreement between the analytical spectra (solid lines) and the DFT samples (disks) validates that phantom, radon, and spectrum are all self consistent for this shape.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/05-triangle/#05-triangle","page":"Triangle","title":"Triangle","text":"This page illustrates the Triangle shape in the Julia package ImagePhantoms.\n\nThis page comes from a single Julia file: 05-triangle.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 05-triangle.ipynb, or open it in binder here: 05-triangle.ipynb.","category":"section"},{"location":"generated/examples/05-triangle/#Setup","page":"Triangle","title":"Setup","text":"Packages needed here.\n\nusing ImagePhantoms: triangle\nusing ImagePhantoms: phantom, radon, spectrum\nimport ImagePhantoms as IP\nusing ImageGeoms: ImageGeom, axesf\nusing MIRTjim: jim, prompt\nusing FFTW: fft, fftshift, ifftshift\nusing Unitful: mm, unit, °\nusing Plots: plot, plot!, scatter!, default\ndefault(markerstrokecolor=:auto)\n\nThe following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/05-triangle/#Overview","page":"Triangle","title":"Overview","text":"For completeness, this package includes a triangle shape for constructing 2D digital image phantoms. (One could describe quite complicated phantoms with a triangular mesh.) The basic shape here is an equilateral triangle whose base is [-1/2,1/2] along the x axis, pointing upwards along the y axis. When defining such a Triangle shape one can specify its center, widths, angle and value. All of the methods in ImagePhantoms support physical units, so we use such units throughout this example. (Using units is recommended but not required.)\n\nDefine a triangle object, using physical units.\n\nwidth = (20mm, 80mm)\nob = triangle((40mm, 30mm), width, π/6, 1.0f0)","category":"section"},{"location":"generated/examples/05-triangle/#Phantom-image-using-phantom","page":"Triangle","title":"Phantom image using phantom","text":"Make a digital image of it using phantom and display it.\n\ndx, dy = 0.8mm, 1.0mm\nM, N = (2^8, 2^8+2)\nx = (-M÷2:M÷2-1) * dx\ny = (-N÷2:N÷2-1) * dy\noversample = 2\nimg = phantom(x, y, [ob], oversample)\njim(x, y, img, \"Triangle image\")\n\nHereafter we use ImageGeoms to simplify the indexing.\n\nM, N = (2^8, 2^8+17) # odd\nig = ImageGeom(dims=(M,N), deltas=(dx,dy), offsets=:dsp)\n@assert axes(ig)[1] ≈ x\noversample = 2\nimg = phantom(axes(ig)..., [ob], oversample)\np1 = jim(axes(ig), img, \"Triangle phantom\", xlabel=\"x\", ylabel=\"y\")\n\nThe image integral should approximate the object area\n\narea = IP.area(ob)\n(sum(img) * prod(ig.deltas), area)","category":"section"},{"location":"generated/examples/05-triangle/#Spectrum-using-spectrum","page":"Triangle","title":"Spectrum using spectrum","text":"There are two ways to examine the spectrum of this image:\n\nusing the analytical Fourier transform of the object via spectrum\napplying the DFT via FFT to the digital image.\n\nBecause the shape has units mm, the spectra axes have units cycles/mm.\n\nvscale = 1 / area # normalize spectra by area\nspectrum_exact = spectrum(axesf(ig)..., [ob]) * vscale\nsp = z -> max(log10(abs(z)/oneunit(abs(z))), -6) # log-scale for display\nclim = (-6, 0) # colorbar limit for display\n(xlabel, ylabel) = (\"ν₁\", \"ν₂\")\np2 = jim(axesf(ig), sp.(spectrum_exact), \"log10|Spectrum|\"; clim, xlabel, ylabel)\n\nSadly fft cannot handle units currently, so this function is a work-around:\n\nfunction myfft(x)\n    u = unit(eltype(x))\n    return fftshift(fft(ifftshift(x) / u)) * u\nend\n\nspectrum_fft = myfft(img) * (prod(ig.deltas) * vscale)\np3 = jim(axesf(ig), sp.(spectrum_fft), \"log10|DFT|\"; clim, xlabel, ylabel)\n\nCompare the DFT and analytical spectra to validate the code\n\nerrf = maximum(abs, spectrum_exact - spectrum_fft) / maximum(abs, spectrum_exact)\n@assert errf < 2e-2\np4 = jim(axesf(ig), 1e3*abs.(spectrum_fft - spectrum_exact),\n    \"|Difference| × 10³\"; xlabel, ylabel)\njim(p1, p4, p2, p3)","category":"section"},{"location":"generated/examples/05-triangle/#Radon-transform-using-radon","page":"Triangle","title":"Radon transform using radon","text":"Examine the Radon transform of the object using radon, and validate it using the projection-slice theorem aka Fourier-slice theorem.\n\ndr = 0.2mm # radial sample spacing\nnr = 2^10 # radial sinogram bins\nr = (-nr÷2:nr÷2-1) * dr # radial samples\nfr = (-nr÷2:nr÷2-1) / nr / dr # corresponding spectral axis\nϕ = deg2rad.(0:180)\nsino = radon(ob).(r, ϕ') # sample Radon transform of a single shape object\nsmax = ob.value * sqrt((width[1]/2)^2 + (width[2] * sqrt(3) / 2)^2)\np5 = jim(r, rad2deg.(ϕ), sino; title=\"sinogram\",\n    xlabel=\"r\", ylabel=\"ϕ\", clim = (0,1) .* smax)\n\nThe maximum sinogram value is about 70mm, which makes sense for a triangle whose height is 80mm * sqrt(3) / 2 and whose base is 20mm, so the longest side is sqrt((10mm)^2 + (80mm * sqrt(3) / 2)^2) = 70 mm.\n\nThe above sampling generated a parallel-beam sinogram, but one could make a fan-beam sinogram by sampling (r, ϕ) appropriately.","category":"section"},{"location":"generated/examples/05-triangle/#Fourier-slice-theorem-illustration","page":"Triangle","title":"Fourier-slice theorem illustration","text":"Pick one particular view angle (55°) and look at its slice and spectra.\n\nia = argmin(abs.(ϕ .- 55°))\nslice = sino[:,ia]\nslice_fft = myfft(slice) * dr\nϕd = round(rad2deg(ϕ[ia]), digits=1)\n\nkx, ky = (fr * cos(ϕ[ia]), fr * sin(ϕ[ia])) # Fourier-slice theorem\nslice_ft = spectrum(ob).(kx, ky)\nerrs = maximum(abs, slice_ft - slice_fft) / maximum(abs, slice_ft)\n@assert errs < 2e-4\n\np3 = plot(r, slice, title=\"profile at ϕ = $ϕd\", label=\"\")\np4 = plot(title=\"1D spectra\")\nscatter!(fr, abs.(slice_fft), label=\"abs fft\", color=:blue)\nscatter!(fr, real(slice_fft), label=\"real fft\", color=:green)\nscatter!(fr, imag(slice_fft), label=\"imag fft\", color=:red,\n    xlims=(-1,1) .* (0.1/mm))\n\nplot!(fr, abs.(slice_ft), label=\"abs\", color=:blue)\nplot!(fr, real(slice_ft), label=\"real\", color=:green)\nplot!(fr, imag(slice_ft), label=\"imag\", color=:red)\nplot(p1, p5, p3, p4)\n\nThe good agreement between the analytical spectra (solid lines) and the DFT samples (disks) validates that phantom, radon, and spectrum are all self consistent for this shape.","category":"section"},{"location":"generated/examples/05-triangle/#Spectrum","page":"Triangle","title":"Spectrum","text":"The spectrum of a triangle is not widely available; for a derivation, see this overleaf file.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/08-focus/#08-focus","page":"Focus Chart","title":"Focus Chart","text":"This page illustrates the focus_chart method in the Julia package ImagePhantoms.\n\nThis page comes from a single Julia file: 08-focus.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 08-focus.ipynb, or open it in binder here: 08-focus.ipynb.","category":"section"},{"location":"generated/examples/08-focus/#Setup","page":"Focus Chart","title":"Setup","text":"Packages needed here.\n\nusing ImagePhantoms: focus_chart, phantom\nusing MIRTjim: jim","category":"section"},{"location":"generated/examples/08-focus/#Focus-chart-phantom-image","page":"Focus Chart","title":"Focus chart phantom image","text":"One of the shapes in ImagePhantoms is an equilateral triangle, and by scaling and translating this shape one can define a focus chart phantom.\n\nob = focus_chart( ; nspoke = 56, value = 4)\nx = range(-1,1,2^9) * 1.1\ny = x\nimage = phantom(ob).(x, y')\njim(x, y, image; title = \"Focus chart phantom\")\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/07-shepp/#07-shepp","page":"Shepp-Logan Phantoms","title":"Shepp-Logan Phantoms","text":"This page illustrates the Shepp-Logan phantoms in the Julia package ImagePhantoms.\n\nThis page comes from a single Julia file: 07-shepp.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 07-shepp.ipynb, or open it in binder here: 07-shepp.ipynb.","category":"section"},{"location":"generated/examples/07-shepp/#Setup","page":"Shepp-Logan Phantoms","title":"Setup","text":"Packages needed here.\n\nusing ImagePhantoms: shepp_logan, SouthPark\nusing ImagePhantoms: SheppLoganToft, SheppLoganEmis, SheppLoganBrainWeb\nusing ImagePhantoms: ellipse_parameters, ellipse, phantom\nusing MIRTjim: jim, prompt\nusing Unitful: g, cm\n\nThe following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/07-shepp/#Overview","page":"Shepp-Logan Phantoms","title":"Overview","text":"There are several variations of the Shepp-Logan phantom available.","category":"section"},{"location":"generated/examples/07-shepp/#CT-version","page":"Shepp-Logan Phantoms","title":"CT version","text":"Original version from: Larry A Shepp, Benjamin F Logan, \"The Fourier reconstruction of a head section,\" IEEE Transactions on Nuclear Science, 21(3):21-42, June 1974. doi\n\nThis (default) version has low soft tissue contrast, so it usually should be displayed with a narrow window the using clim option:\n\nimage1 = shepp_logan(256) # CT version by default\njim(image1, \"SheppLogan (original CT version)\", clim=(0.95, 1.05))","category":"section"},{"location":"generated/examples/07-shepp/#Over-sampling","page":"Shepp-Logan Phantoms","title":"Over-sampling","text":"When generating ellipse phantoms, it is generally preferable to \"over-sample\" the ellipse values within each pixel to account for partial volume effect. A factor of 3 over-sampling (along both axes) typically suffices, so this factor is the default for the shepp_logan method. Here is how the phantom image looks without over-sampling:\n\nimage1o = shepp_logan(256; oversample=1)\njim(image1o, \"No over sampling\", clim=(0.95,1.05))\n\nNote that boundaries of the interior ellipses look smoother in the original version with the default 3× over-sampling. Most of the remaining examples use the recommended default over-sampling.","category":"section"},{"location":"generated/examples/07-shepp/#Units","page":"Shepp-Logan Phantoms","title":"Units","text":"The original Shepp-Logan phantom in the paper as cited above did not give any units for the grayscale values, but the values were described as \"densities\" and indeed the values are reasonable for head CT scans if interpreted as having g/cm³ units. Here is a version with units.\n\nimage1u = image1 * g/cm^3\njim(image1u, \"SheppLogan with density units\", clim=(0.95,1.05))","category":"section"},{"location":"generated/examples/07-shepp/#Toft-version","page":"Shepp-Logan Phantoms","title":"Toft version","text":"This version is from: Toft, Peter Aundal & Sørensen, John Aasted \"The Radon transform-theory and implementation,\" Technical University of Denmark (DTU), 1996. Page 201. pdf\n\nimage2 = shepp_logan(256, SheppLoganToft())\njim(image2, \"SheppLoganToft\")","category":"section"},{"location":"generated/examples/07-shepp/#Emission-tomography-version","page":"Shepp-Logan Phantoms","title":"Emission tomography version","text":"This version has low intensity for the skull because typical PET/SPECT radiotracers do not accumulate in bone regions. It is probably also useful for MRI, because typical MRI scans have low signal from bone.\n\nimage3 = shepp_logan(256, SheppLoganEmis())\njim(image3, \"SheppLoganEmis\")","category":"section"},{"location":"generated/examples/07-shepp/#BrainWeb-version","page":"Shepp-Logan Phantoms","title":"BrainWeb version","text":"This version was inspired by the BrainWeb phantoms that have integer indices for each of the different regions. It should not be used directly, but rather one should assign meaningful intensity values to each of the integer indices.\n\nimage4 = shepp_logan(256, SheppLoganBrainWeb())\njim(image4, \"SheppLoganBrainWeb\")\n\nFor the BrainWeb version, there is no over-sampling by default, to preserve the integer indices.","category":"section"},{"location":"generated/examples/07-shepp/#Disjoint-middle-ellipses","page":"Shepp-Logan Phantoms","title":"Disjoint middle ellipses","text":"Sometimes it can be more convenient to have the middle ellipses be non-overlapping:\n\nparams = ellipse_parameters(SheppLoganBrainWeb(), disjoint=true)\nparams = [(p[1:5]..., i) for (i, p) in enumerate(params)]\nob = ellipse(params)\nx = range(-0.4, 0.4, 206)\ny = range(-0.5, 0.5, 256)\noversample = 3\nimage5 = phantom(x, y, ob, oversample)\njim(x, y, image5, \"Disjoint\"; aspect_ratio = 1)","category":"section"},{"location":"generated/examples/07-shepp/#Comedy-version","page":"Shepp-Logan Phantoms","title":"Comedy version","text":"image6 = shepp_logan(256, SouthPark(); fovs=(1,1))\njim(image6, \"SouthPark\")\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#ImagePhantoms.jl-Documentation","page":"Home","title":"ImagePhantoms.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"This Julia package ImagePhantoms provides tools for constructing digital software \"phantoms\" used for testing image reconstruction algorithms. The most famous such phantom is the \"Shepp Logan\" phantom from this 1974 paper. (A variant of that phantom serves as the logo for the JuliaImageRecon suite of tools.)\n\nA phantom is a collection (iterable) of shapes (e.g., ellipses, rectangles). One purpose of this package is to avoid the inverse crime of using a discretized or sampled image to generate sinograms or spectra.\n\nThe shapes in this package have methods useful for simulating data:\n\nphantom returns a function of (x,y) or (x,y,z)  that one can evaluate on a grid to make a pixelated or voxelized phantom.\nradon returns a function of (r,ϕ)  that one can evaluate on a grid  to make a sampled 2D parallel-beam sinogram,  or evaluate appropriately to make a sampled fan-beam sinogram.  For 3D objects, radon returns a function of (u,v,ϕ,θ)  that one can evaluate to compute projection views.  See the \"3D geometry\" example  for description of the coordinate system.\nspectrum returns a function of spatial frequencies that one can sample to simulate k-space data (e.g., in MRI).\n\nSee the Examples tab for details.\n\nThe Michigan Image Reconstruction Toolbox (MIRT) currently has an older interface ellipse_im, rect_im, etc., similar to the functions of the same name in the Matlab version of MIRT provided for backward compatibility. Using ImagePhantoms is recommended for Julia work.","category":"section"},{"location":"#Units","page":"Home","title":"Units","text":"This package allows the shapes to be described with physical units, e.g., using Unitful.jl. Using units is recommended but not required. If units are not used explicitly, then the user must be especially careful to use values corresponding to consistent units. For example, if the shape sizes are in cm, then\n\nthe arguments to phantom must also be in cm units,\nthe first (r) argument to radon must also be in cm and the ϕ argument must be in radians,\nthe spatial frequency arguments to spectrum must be in cycles/cm units.","category":"section"},{"location":"generated/examples/37-shepp3/#37-shepp3","page":"3D Shepp-Logan Phantom","title":"3D Shepp-Logan Phantom","text":"This page illustrates the 3D Shepp-Logan phantom(s) in the Julia package ImagePhantoms.\n\nThis page comes from a single Julia file: 37-shepp3.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 37-shepp3.ipynb, or open it in binder here: 37-shepp3.ipynb.","category":"section"},{"location":"generated/examples/37-shepp3/#Setup","page":"3D Shepp-Logan Phantom","title":"Setup","text":"Packages needed here.\n\nusing ImagePhantoms: ellipsoid_parameters, ellipsoid, phantom\nusing ImageGeoms: ImageGeom, axes\nusing MIRTjim: jim, prompt\nusing Unitful: g, cm\n\nThe following line is helpful when running this file as a script; it prompts user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/37-shepp3/#Overview","page":"3D Shepp-Logan Phantom","title":"Overview","text":"Currently this package provides one version of a 3D Shepp-Logan phantom consisting of ellipsoids.\n\nFor completeness, we illustrate it using units, though units are not required.\n\nWe use cm for the spatial units and g/cm³ (density) for the tissue values.\n\nfovs = (24cm, 24cm, 20cm)\nu = (1, 1, 1*g/cm^3)\nparams = ellipsoid_parameters( ; fovs, u)\nob = ellipsoid(params); # Vector of Ellipsoid objects\nnothing #hide\n\nTo visualize this phantom, we sample it with the help of ImageGeoms, using over-sampling to account for partial volume effects.\n\ndims = (128,130,30)\nig = ImageGeom( ; dims, deltas = fovs ./ dims )\n\noversample = 3\nimage = phantom(axes(ig)..., ob, oversample)\nclim = (0.95, 1.05)\njim(axes(ig)[1:2]..., image; title = \"3D Shepp-Logan phantom slices\", clim)\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
